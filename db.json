[{"title":"JavaScript - 作用域和闭包","url":"/2023/12/10/JavaScript/JavaScript%20-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","categories":["前端"],"tags":["JavaScript"]},{"title":"HTTP概述","url":"/2023/12/01/Network/HTTP%E6%A6%82%E8%BF%B0/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","categories":["基础"],"tags":["计算机网络"]},{"title":"Objecitve-C - 对象的类型和动态绑定","url":"/2023/12/06/Objective-C/Objecitve-C%20-%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"动态绑定\"><a href=\"#动态绑定\" class=\"headerlink\" title=\"动态绑定\"></a>动态绑定</h1><h2 id=\"什么是动态绑定\"><a href=\"#什么是动态绑定\" class=\"headerlink\" title=\"什么是动态绑定\"></a>什么是动态绑定</h2><p>实际的程序会使用各种各样的类的实例对象，所有这些对象都可以用id类型来表示，因为id是通用的对象类型，可以用来存储任何类的对象。但这样一来，程序中就会出现无法区分某个实例对象到底是哪个类的对象的情况。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/NSObject.h&gt;</span><br><span class=\"line\">#import &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface A : NSObject</span><br><span class=\"line\">- (void)whoAreYou;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation A</span><br><span class=\"line\">- (void)whoAreYou &#123; printf(&quot;I&#x27;m A\\n&quot;); &#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@interface B : NSObject</span><br><span class=\"line\">- (void)whoAreYou;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation B</span><br><span class=\"line\">- (void)whoAreYou &#123; printf(&quot;I&#x27;n B\\n&quot;); &#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void) &#123;</span><br><span class=\"line\">\tid obj;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\"></span><br><span class=\"line\">\tscanf(&quot;%d&quot;, &amp;n);</span><br><span class=\"line\">\tswitch (n) &#123;</span><br><span class=\"line\">\t\tcase 0: obj = [[A alloc] init]; break;</span><br><span class=\"line\">\t\tcase 1: obj = [[B alloc] init]; break;</span><br><span class=\"line\">\t\tcase 2: obj = [[NSObject alloc] init]; break;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t[obj whoAreYou];</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该程序会根据从终端读入的数字的不同，让obj指向不同的类的对象。类A和B中都实现了<code>whoAreYou</code>方法，NSObject中没实现这个方法。但编译时不会给出任何警告信息，会正常生成可执行文件。但是执行程序时一旦输入2，则会获得以下异常</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Terminating app due to uncaught exception &#x27;NSInvalidArgumentException&#x27;, reason: &#x27;- [NSObject whoAreYou]: unrecognized selector sent to instance 0x103f00&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>出错的原因在于类NSObject的实例对象中没有实现<code>whoAreYou</code>方法，所以出现运行时错误。而编译时之所以没出错，是因为编译时无法确定存储在id中的对象的类型。<br>Objective-C中的消息是在运行时才去绑定的。运行时系统首先会确定接收者的类型（动态类型识别），然后根据消息名在类的方法列表里选择相应的方法执行，如果没有找到就到父类中继续寻找，假如一直找到NSObject也没有找到要调用的方法，就会报告上述不能识别消息的错误。<br><strong>动态绑定</strong>（dynamic binding) 指的就是在程序执行时才确定对象的属性和需要响应的消息。</p>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>在面向对象的程序设计理论中，<strong>多态(polymor phism)</strong> 是指，同一操作作用于不同的类的实例时，将产生不同的执行结果。即不同类的对象收到相同的消息时，也能得到不同的结果。<br>我们通过一个绘制图形的例子来理解多态的特性。在面向过程的程序设计中，应该如此编写：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(target-&gt;kind) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Line:</span><br><span class=\"line\">\t\tlineDragged(direction);</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Circle:</span><br><span class=\"line\">\t\tcircleMove(direction);</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Rectangle:</span><br><span class=\"line\">\t\tRectangleMove(direction);</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而使用多态的情况下，只要将各个图形都定义成一个类，其中实现自己的direction方法，并根据target实际指向的对象的不同，来调用不同的direction操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[target move:direction];</span><br></pre></td></tr></table></figure>\n<p>多态的另外一个优点就是：利用继承可以更容易的定义新的类</p>\n<h1 id=\"作为类型的类\"><a href=\"#作为类型的类\" class=\"headerlink\" title=\"作为类型的类\"></a>作为类型的类</h1><h2 id=\"把类作为一种类型\"><a href=\"#把类作为一种类型\" class=\"headerlink\" title=\"把类作为一种类型\"></a>把类作为一种类型</h2><p>我们可以把定义好的类作为对象的类型，也可以作为变量的类型，方法或函数的参数和返回值类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Volume *v1, *v2;</span><br><span class=\"line\">v1 = [[Volume alloc] initWithMin: 0 max: 10 step1: 1];</span><br><span class=\"line\">v2 = v1;</span><br><span class=\"line\">[v1 up];</span><br><span class=\"line\">printf(&quot;%d\\n&quot;, [v2 value]);</span><br></pre></td></tr></table></figure>\n<p>其中v2指向v1所指的对象。所以输出的是改变后的值。同样，当消息的参数是对象时，实际上传递的是指向这个对象的指针而不是对象本身，根据消息处理中操作的不同，有可能会更改对象的值。</p>\n<h2 id=\"空指针nil\"><a href=\"#空指针nil\" class=\"headerlink\" title=\"空指针nil\"></a>空指针nil</h2><p>Objective-C中，nil表示一个空的对象，这个对象的指针指向空。nil是指向id类型的指针，值为0 。初始化方法失败的时候通常会返回nil。<br>新生成一个实例变量的时候，alloc方法会把数值类型的实例变量初始化为0，id和其他类型的指针变量也会被初始化为nil<br>返回值为id类型的方法中，如果处理出错的话一般也会返回nil。调用端会采用如下语句来判断方法调用是否成功</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if ([list entryForKey: &quot;NeXT&quot;])</span><br></pre></td></tr></table></figure>\n<h2 id=\"静态类型检查\"><a href=\"#静态类型检查\" class=\"headerlink\" title=\"静态类型检查\"></a>静态类型检查</h2><p>虽然在Objective-C中id数据类型可以用来存储任何类型的对象，但绝大多数情况下我们还是将一个变量声明为特定类的对象，这种情况称为静态类型。使用静态类型时，编译器在编译时可以进行类型检查，如果类型不符合会提示警告。<br>我们可以通过下面的这个例子来看看Objective-C的类型检查。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/NSObject.h&gt;</span><br><span class=\"line\">#import &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface A : NSObject</span><br><span class=\"line\">- (void)whoAreYou;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation A : NSObject</span><br><span class=\"line\">- (void)whoAreYou &#123; printf(&quot;I&#x27;m A\\n&quot;); &#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@interface B : A</span><br><span class=\"line\"> - (void)whoAreYou;</span><br><span class=\"line\"> - (void)sayHello;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation B</span><br><span class=\"line\">- (void)whoAreYou &#123; printf(&quot;I&#x27;m B\\n&quot;); &#125; /* override */</span><br><span class=\"line\">- (void)sayHello &#123; printf(&quot;Hello\\n&quot;); &#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@interface C : NSObject</span><br><span class=\"line\">- (void) printName;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation C</span><br><span class=\"line\">- (void)printName &#123; printf(&quot;I&#x27;m C\\n&quot;); &#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void) &#123;</span><br><span class=\"line\">\tA *a, *b;</span><br><span class=\"line\">\tC *c;</span><br><span class=\"line\">\ta = [[A alloc] init];</span><br><span class=\"line\">\tb = [[B alloc] init];</span><br><span class=\"line\">\tc = [[C alloc] init];</span><br><span class=\"line\">\t[a whoAreYou];</span><br><span class=\"line\">\t[b whoAreYou];</span><br><span class=\"line\">\t[c whoAreYou];</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类A和类是C是相互独立的两个类，类B是类A的子类。main函数中所有的变量都采用静态类型定义<br>编写这段程序会有如下警告。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">warning: &#x27;C&#x27; may not respond to &#x27;whoAreYou&#x27;</span><br></pre></td></tr></table></figure>\n<p>虽然变量a和b都被声明为类A类型的变量，但编译器并没有提示警告。原因在于，如果仅仅使用父类中定义的功能，则变量的类型声明为父类也是没有问题的。<br>如果我们修改b调用的方法为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[b sayHello];</span><br></pre></td></tr></table></figure>\n<p>则会提示报错，因为我们将b定义为类型A。不过程序可以执行，因为b确实有sayHello方法。<br>我们可以使用强制类型转换，不让编译起报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[(B *)b sayHello];</span><br></pre></td></tr></table></figure>\n<p>但是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[(B *)a whoAreYou];</span><br></pre></td></tr></table></figure>\n<p>实际输出还是<code>I&#39;m A</code>，也就是说强制类型转换无效，实际执行的方法是由对象的类型决定的。</p>\n<h2 id=\"静态类型检查的总结\"><a href=\"#静态类型检查的总结\" class=\"headerlink\" title=\"静态类型检查的总结\"></a>静态类型检查的总结</h2><ol>\n<li>对于id类型的变量，调用任何方法都能够通过编译（当然调用不恰当的方法会出现运行时错误）</li>\n<li>id类型的变量和被定义为特定类的变量之间是可以相互赋值的</li>\n<li>被定义为特定类对象的变量（静态类型），如果调用类或父类中未定义的方法，编译器就会提示警告</li>\n<li>如果是静态类型的变量，子类类型的实例变量可以赋值给父类类型的实例变量</li>\n<li>若是静态类型的变量，父类类型的实例变量不可以赋值给子类类型的实例变量</li>\n<li>若是要判断到底是哪个类的方法被执行，不要看变量声明的类型，而是要看实际执行时这个变量的类型</li>\n<li>id类型并不是<code>NSObject *</code>类型<br>Objective-C的静态类型检查是在编译期间完成的。向一个静态类型的对象发送消息时，编译器可以确保接收者可以响应该消息，否则会发出警告；当把一个静态类型的对象赋值给一个静态类型的变量时，编译器可以确保这种赋值是兼容的，否则会发出警告。运行时实际被执行的方法同变量定义是的类型无关。</li>\n</ol>\n<h1 id=\"编程中的类型定义\"><a href=\"#编程中的类型定义\" class=\"headerlink\" title=\"编程中的类型定义\"></a>编程中的类型定义</h1><h2 id=\"签名不一致时的情况\"><a href=\"#签名不一致时的情况\" class=\"headerlink\" title=\"签名不一致时的情况\"></a>签名不一致时的情况</h2><p><strong>消息选择器</strong>中并不包含参数和返回值的类型的信息，消息选择器和这些类型信息结合起来构成<strong>签名</strong>( signature)，签名被用于在运行时标记一个方法。接口文件中方法的定义也叫做签名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (id)cellAtRow: (int)row column: (int)col;</span><br></pre></td></tr></table></figure>\n<p>Cocoa提供了类<code>NSMethodSignature</code>，以面向对象的方式来记录方法的参数个数、参数类型和返回值类型等信息。这个类的实例也叫做方法签名。<br>Objective-C中选择器相同的消息，参数和返回值的类型也应该是相同的。否则编译器就会提示警告<br><strong>重载：</strong> Objective-C是动态语言，参数的类型是在运行时确定的，所以不支持这种根据参数类型的不同来调用不同函数的重载。但是可以通过动态绑定让同一个消息选择器执行不同的功能来实现重载</p>\n<h2 id=\"类的前置声明\"><a href=\"#类的前置声明\" class=\"headerlink\" title=\"类的前置声明\"></a>类的前置声明</h2><p>当我定义一个类的时候，有时会将类实例变量、类方法的参数和返回值的类型指定为另外一个类。这种情况该如何定义： 可以在新定义的类的接口文件中引用原有类的头文件。<br>但是这种方式有一些缺点，头文件中除了类名之外，还有各种各样的其他信息的定义，而且还会引入新的引入。<br>如果仅仅是在类型定义的时候使用一下类名，则可以采用<strong>类的前置声明</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/NSObject.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@class Volume; // 声明要使用类Volume</span><br></pre></td></tr></table></figure>\n<p>通过编译指令<code>@class</code> 告诉编译器Volume是一个类名。使用<code>@class</code>可以提升程序整体的编译速度。但是如果新定义的类中要使用原有类的具体成员或方法，就一定要引入原有类的头文件。</p>\n<h1 id=\"实例变量的数据封装\"><a href=\"#实例变量的数据封装\" class=\"headerlink\" title=\"实例变量的数据封装\"></a>实例变量的数据封装</h1><h2 id=\"实例变量的访问权限\"><a href=\"#实例变量的访问权限\" class=\"headerlink\" title=\"实例变量的访问权限\"></a>实例变量的访问权限</h2><p>Objective-C原则上不允许从对象外直接访问对象的实例变量。但是类A的方法中可以直接访问类A中包含self以外的其他实例的实例变量。同类型检查一样，能不能访问对象的实例变量也需要检查，这个检查在编译时完成。因此，只能访问使用静态类型定义的实例变量的内部变量。<br>下面是访问obj对象中实例变量myvar的语句写法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">obj-&gt;myvar</span><br></pre></td></tr></table></figure>\n<p>只有被访问的类的实例对象与方法所在类的类型一致时才能访问。如果是其他类，即使是父类对象，则无法访问。</p>\n<h2 id=\"访问器\"><a href=\"#访问器\" class=\"headerlink\" title=\"访问器\"></a>访问器</h2><p>Objective-C不允许从外部直接访问和修改实例对象的属性。而仅仅可以访问同一个类的其他实例对象的变量。我们通常会定义专门的方法来访问或修改实例变量。<br>例如，类中有一个float类型、变量名交weight的属性，从类外部访问这个属性的<strong>方法应和属性同名</strong>，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (float) weight</span><br></pre></td></tr></table></figure>\n<p>定义修改改属性的方法时，可以<strong>用set作为前缀，之后接要更改的属性的名称，属性名的第一歌字母要求大写</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (void) setWeight: (float)value</span><br></pre></td></tr></table></figure>\n<p>这种用于读取、修改实例对象属性的方法称为访问器或访问方法。</p>\n<h2 id=\"实例变量的可见性\"><a href=\"#实例变量的可见性\" class=\"headerlink\" title=\"实例变量的可见性\"></a>实例变量的可见性</h2><p>能否从外部访问实例变量决定了访问的**可见性(visibility)**。Objective-C中有四种可见性修饰符。但是需要注意的可见性修饰符并不影响通过访问器访问实例变量，只影响直接访问</p>\n<ul>\n<li><code>@private</code>: 只能在声明它的类内部访问，子类中不可以访问。</li>\n<li><code>@protected</code>: 能够被声明它的类和任何子类访问。没有显示置顶可见性的实例变量都是次属性</li>\n<li><code>@public</code>:作用范围最大，本类和其他类都可以直接访问</li>\n<li><code>@package</code>: 类所在的框架内，可以像public一样访问，框架外则同private<br>可以在实现部分定义实例变量。因为实例变量定义在实现文件中，因此即便外部模块拿到接口文件，也不知道类中定义了那些实例变量。所以这种形式定义的实例变量，可见性默认是private的，子类无法直接访问，只能通过访问方法或者属性声明的方法访问</li>\n</ul>\n<h1 id=\"类对象\"><a href=\"#类对象\" class=\"headerlink\" title=\"类对象\"></a>类对象</h1><h2 id=\"什么是类对象\"><a href=\"#什么是类对象\" class=\"headerlink\" title=\"什么是类对象\"></a>什么是类对象</h2><p>面向对象的语言中对类有两种认识，一种认为类只作为类型的定义，程序运行时不作为实体存在。另外一种认为类本身也作为一个对象存在。我们把后一种定义中类的对象称为<strong>类对象</strong>。<br>类对象有自己的方法和变量，分别称为类方法和类变量。与类实例的实例方法和实例变量进行区分。<br>Objective-C中类对象也称为factory，所以类方法也会被称为factory method.<br>类方法的一个典型例子就是创建类的实例对象: <code>[Class alloc]</code>。类对象接收alloc消息，并返回类的实例。<br>类对象在程序执行时自动生成，每个类只有一个类对象，不需要手动生成。每个类的所有实例对象都可以使用类方法。类方法可以访问类对象管理的变量。</p>\n<h2 id=\"类对象的类型\"><a href=\"#类对象的类型\" class=\"headerlink\" title=\"类对象的类型\"></a>类对象的类型</h2><p>id类型可以表示任何对象，类对象也可以用id类型来表示。Objective-C中还专门定义了一个<strong>Class</strong>类型用来表示类对象。所有的类对象都是Class类型。Class和id一样都是指针类型，只是一个地址，并不需要了解实际指向的内容。<strong>Nil</strong>被用来表示空指针（是Class，而不是对象），实际值为0.<br>NSObject中定义了类方法class，所有的类都可以使用这个方法来获取类对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class theClasss = flag ? [Volume class] : [MuteVolume class];</span><br><span class=\"line\">id v = [[theClass alloc] init];</span><br></pre></td></tr></table></figure>\n<p>将类名定义为消息接收者是类对象特有的功能，除此之外类名只能在类型定义时使用。<br>除了class类方法外，类NSObject还是有一个class实例方法。所有的实例对象都可以使用class实例方法，这个方法返回的是对象所属类的类对象。<br><strong>类方法的定义方式：</strong> 与实例方法的定义基本相同，唯一的区别在于开头的<code>-</code>号换成<code>+</code><br>继承的情况下，子类可以访问父类的类方法。<br>但是需要注意的是，<strong>类方法不能访问类中定义的实例变量和实例方法</strong>。类对象只有一个，类的实例对象可以有任意个。所以，如果类对象可以访问实例变量，就会不清楚访问的到底是哪个实例对象的变量。<br>其次，类方法在执行时使用self代表类对象自身，因此可以i通过给self发送消息的方式来调用类中的其他类方法。调用父类的类方法时，则使用关键字super</p>\n<h2 id=\"类变量\"><a href=\"#类变量\" class=\"headerlink\" title=\"类变量\"></a>类变量</h2><p>Objective-C不支持类变量（即静态成员变量）。Objective-C通过在实现文件中定义<strong>静态变量</strong>的方法来代替类变量。Objective-C在实现文件中定义了静态变量后，该变量的作用域就变为只在该文件中内有效。也就是说只有类的类方法和实例方法可以访问这个变量。在继承的情况下，因为static变量的作用域仅限于定义它的文件内，所以子类无法直接访问父类中定义的static变量，只能通过访问方法访问。</p>\n<h2 id=\"类对象的初始化\"><a href=\"#类对象的初始化\" class=\"headerlink\" title=\"类对象的初始化\"></a>类对象的初始化</h2><p>Objective-C的跟类NSObject中存在一个initialize类方法，可以通过使用这个方法来为各类对象进行初始化。在每个类接收到消息之前，为这个类调用一次initialize，调用之前要先调用父类的initialize方法。每个类的initialize方法只被调用一次。因为在初始化的过程中会自动调用父类的initialize方法，所以子类的initialize方法中不用显示调用父类的initialize方法。</p>\n","categories":["iOS"],"tags":["Objective-C"]},{"title":"Objective-C - 程序设计","url":"/2023/11/29/Objective-C/Objective-C%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"对象和消息\"><a href=\"#对象和消息\" class=\"headerlink\" title=\"对象和消息\"></a>对象和消息</h1><h2 id=\"消息表达式\"><a href=\"#消息表达式\" class=\"headerlink\" title=\"消息表达式\"></a>消息表达式</h2><p>在Objective-C中，id类型是一个独特的数据类型。id类型的变量可以存放任何数据类型的对象。定义一个id类型变量obj的方法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">id obj;</span><br></pre></td></tr></table></figure>\n<p>而向obj发送msg消息的语法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[obj msg];</span><br></pre></td></tr></table></figure>\n<p>这就是<strong>消息表达式</strong>的语法。其中，消息接收者是一个对象。<br>Objective-C允许嵌套消息表达式，每个消息表达式的返回值都可以作为消息的接收者，继续接收消息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[[[obj msg1] msg2] msg3];</span><br></pre></td></tr></table></figure>\n<p>消息由<strong>消息关键字</strong>组成，消息关键字的命名规则同变量名的命名规则一样。<br>消息关键字的末尾有”:”时，表示这个消息带有参数。“:“后面紧跟的就是实际的参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[printInfo setLeftMargin: 60.0];</span><br></pre></td></tr></table></figure>\n<p>发送带有多个参数的消息的时候，可以通过多个“关键字: 变量“的写法完成调用。也可以省略关键字而至通过”:”将变量连接起来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[manager fileExistsAtPath: dirname isDirectory: &amp;isDir];</span><br><span class=\"line\">[view lineTo: 1.412: (y + 1.0)];</span><br></pre></td></tr></table></figure>\n\n<p>函数通过函数名来区分，而在Objective-C中，消息是通过消息名进行区分的。带参数和不带参数的消息名，例如”copy”和”copy:”是不同的消息名。</p>\n<h2 id=\"实例变量的生成和初始化\"><a href=\"#实例变量的生成和初始化\" class=\"headerlink\" title=\"实例变量的生成和初始化\"></a>实例变量的生成和初始化</h2><p>在OC中使用一个对象前，首先需要调用类的构造函数以生成对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[类名 alloc];</span><br></pre></td></tr></table></figure>\n<p>alloc执行后即可完成对象所需空间的分配。但还没有对对象进行初始化。不同的类会提供不同的初始化方法，同一个类也可能提供多个初始化方法。<br>Cocoa中的初始化方法通常都是init或以init开头。下面的语句完整地创建并初始化了Cocoa中的某个类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[[类名 alloc] init]</span><br></pre></td></tr></table></figure>\n<p>另外，对象生成后只能调用一次初始化方法，来为对象中的各个变量设置初值。但是初始化方法不具备将对象中的信息重置的功能。如果需要将对象中的属性重置，则需要额外实现一个函数。<br>另外，有的类的方法会返回一个初始化好的对象，所以可以不通过alloca而使用别的方法来生成对象。</p>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"类的接口声明\"><a href=\"#类的接口声明\" class=\"headerlink\" title=\"类的接口声明\"></a>类的接口声明</h2><p>在OC中，接口（interface）和实现（implementation）是分离开的。<br>类的接口部分定义了类的实例变量和方法。类的接口声明通常声明为头文件，提供给要调用这个类的模块引用。接口的定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@interface 类名 : 父类</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t实例变量的定义;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">方法声明;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>在Objective-C中，类接口的声明以编译指令<code>@interface</code>开头，以<code>@end</code>结尾。所有Objective-C编译指令都以<code>@</code>字符开头。<br>实例变量的声明和C语言中定义变量的方法一样，使用<code>变量类型 变量名</code>的形式。<br>而方法的声明如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-  (id)callAtRow: (int)row column:(int)col;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类的实现\"><a href=\"#类的实现\" class=\"headerlink\" title=\"类的实现\"></a>类的实现</h2><p>类的实现部分以编译指令<code>@implementation</code>开始，以<code>@end</code>结束。具体语法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@implementation</span><br><span class=\"line\">方法的实现</span><br><span class=\"line\">...</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>类的实现部分不用再次声明父类。实现部分包含了接口部分声明的所有方法的实现。<br>方法实现部分的第一行代码和方法声明部分完全相同，以后接上<code>&#123;&#125;</code>，并将具体实现的代码写在<code>&#123;&#125;</code>里面。<br>方法内部可以自由使用类的实例变量。</p>\n","categories":["iOS"],"tags":["Objective-C"]},{"title":"Objective-C - 类和继承","url":"/2023/11/30/Objective-C/Objective-C%20-%20%E7%B1%BB%E5%92%8C%E7%BB%A7%E6%89%BF/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"继承的概念\"><a href=\"#继承的概念\" class=\"headerlink\" title=\"继承的概念\"></a>继承的概念</h1><h2 id=\"父类和子类\"><a href=\"#父类和子类\" class=\"headerlink\" title=\"父类和子类\"></a>父类和子类</h2><p>我们在定义一个新类的类的时候，经常会遇到要定义的新类是某个类的扩展或者是对某个类的修正。这种情况，如果可以在已有类的基础上追加内容来定义新类，那么新类的定义将会变得更简单。<br>向这种通过扩展或者修改即有类来定义新类的方法叫继承(inheritance)。在继承关系中，被继承的类叫<strong>父类</strong>，通过继承关系新建的类称为子类。<br>继承意味着子类继承父类的所有特性，父类的数据成员和成员函数自动成为子类的数据成员和成员函数。除此之外，子类还可以：</p>\n<ul>\n<li>追加新的方法</li>\n<li>追加新的实例变量</li>\n<li>重新定义父类的方法<br>子类中重新定义父类的方法的行为叫做<strong>重写</strong>。为了避免命名上的混乱，C++中也将父类称为<strong>基类</strong> ，把子类称为<strong>派生类</strong>或<strong>导出类</strong></li>\n</ul>\n<h2 id=\"类的层次结构\"><a href=\"#类的层次结构\" class=\"headerlink\" title=\"类的层次结构\"></a>类的层次结构</h2><p>假如以某个类为父类生成若干子类，然后再继承这些子类并生成更多的子类，如此循环下去就可能会生成一棵倒立的树，它由通过继承而彼此关联的类组成，这样的树称为类层次结构。位于类层次最顶端的类称为<strong>根类</strong><br><strong>NSObject</strong>是Cocoa环境下的根类，Cocoa中所有的类都直接或间接地继承NSObject。新建的任何类都必须是NSObject或它的继承类的子类。NSObject中定义了所有Objective-C对象的基本方法。</p>\n<h1 id=\"利用继承定义新类\"><a href=\"#利用继承定义新类\" class=\"headerlink\" title=\"利用继承定义新类\"></a>利用继承定义新类</h1><h2 id=\"继承的定义\"><a href=\"#继承的定义\" class=\"headerlink\" title=\"继承的定义\"></a>继承的定义</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@interface 类名 : 父类名</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t实例变量的声明;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">方法声明;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>Objective-C中所有的类都要继承根类，而NSObject是Objective-C中所有类的根类。如果子类有想继承的类，就要直接指明该类为父类，否则就需要指定NSObject为父类。</p>\n<h2 id=\"类定义和头文件\"><a href=\"#类定义和头文件\" class=\"headerlink\" title=\"类定义和头文件\"></a>类定义和头文件</h2><p>接口部分通常被声明为一个头文件，而这对继承来说也很重要。假设有一个已经定义好的类Alpha，那么头文件<code>Alpha.h</code>就应该已经存在。要定义类Alpha的子类Beta的时候，头文件<code>Beta.h</code>中必须包含<code>Alpha.h</code>。不知道父类定义的话是无法定义子类的。所以<strong>包含父类接口的头文件是必须的</strong>。<br>类的实现部分必须引入包含类的接口部分的头文件。实现部分需要包含新增和重写的方法的实现。当然实现部分也可以定义各种局部函数和变量。<br>类的定义可以不断地往下扩展，但无论怎么扩展，只要保证了这种头文件的引入方式，任何一个派生类中就能使用父类中定义的变量和方法。</p>\n<h2 id=\"调用父类的方法\"><a href=\"#调用父类的方法\" class=\"headerlink\" title=\"调用父类的方法\"></a>调用父类的方法</h2><p>子类继承父类之后，如果希望调用父类的方法，可以通过<strong>super</strong>关键字来发送消息。使用super发送消息后，就会调用父类或父类的父类中定义的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[super method];</span><br></pre></td></tr></table></figure>\n<p>super和self不同，并不确定指向某个对象。所以super只能被用于调用父类的方法，不能通过super完成赋值，也不能把方法的返回值指定为super。</p>\n<h2 id=\"初始化方法的定义\"><a href=\"#初始化方法的定义\" class=\"headerlink\" title=\"初始化方法的定义\"></a>初始化方法的定义</h2><p>新追加的实例变量有时需要被初始化。另外，子类也可能需要同父类不同的初始化方法。这些情况下就需要为子类定义自己的初始化方法。<br>子类中重写init初始化方法的时候，通常按照一下逻辑：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (id)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tself = [super init] /* 一定要在第一行调用父类的init方法 */</span><br><span class=\"line\">\tif (self != nil) &#123;</span><br><span class=\"line\">\t\t子类专有的初始化操作</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果所有类的初始化方法都遵循先调用父类init方法的写法，那么根类NSObject的init方法就一定会被执行。否则生成的对象就无法使用。与此同时，这样做也可以防止漏掉父类中定义的实力变量的初始化。<br>执行的时候父类的初始化方法可能会出错。出错时则返回nil，这种情况下子类也不需要再进行初始化，直接返回nil就可以了。<br>生成实力对象的方法alloc会把实力对象的变量都初始化为0(后续会提到实力变量isa除外)。所以，如果子类中新追加的实例变量的初值可以为0，则可以跳过子类的初始化。但是为了明确是否可以省略，最好为初值可为0的变量加上注释。<br>从程序的书写角度来说，设定初始值的方法有两种，既可以在初始化方法中一次性完成实例变量的初始化，也可以在初始化方法中先设置实例变量为默认值，然后再调用别的方法来设置实例变量。</p>\n<h1 id=\"使用继承的程序示例\"><a href=\"#使用继承的程序示例\" class=\"headerlink\" title=\"使用继承的程序示例\"></a>使用继承的程序示例</h1><h2 id=\"追加新方法的例子\"><a href=\"#追加新方法的例子\" class=\"headerlink\" title=\"追加新方法的例子\"></a>追加新方法的例子</h2><p>我们定义一个带有静音功能的类MuteVolume。该类只有一个功能，即当收到mute消息时，设置音量为最小</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// MuteVolume.h</span><br><span class=\"line\">#import &quot;Volume.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface MuteVolume</span><br><span class=\"line\">- (id)mute;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// MuteVolume.m</span><br><span class=\"line\">#import &quot;MuteVolume.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MuteVolume</span><br><span class=\"line\"></span><br><span class=\"line\">- (id) mute</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tval = min;</span><br><span class=\"line\">\treturn self</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法重写的例子\"><a href=\"#方法重写的例子\" class=\"headerlink\" title=\"方法重写的例子\"></a>方法重写的例子</h2><p>假设该例子要实现两个功能。第一个功能是，当再次收到mute消息时，音量会恢复原职；第二个功能是，在静音状态下收到up或者down消息时，会返回最小音量，同时改变音量值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// MuteVolume.h</span><br><span class=\"line\">@interface MuteVolume : Volume</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBOOL muting;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* override */</span><br><span class=\"line\">- (id)initWIthMin: (int)a Max: (int)b step: (int)s;</span><br><span class=\"line\">- (int)value;</span><br><span class=\"line\">- (id) mute;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// MuteVolume.m</span><br><span class=\"line\">#import &quot;MuteVolume.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MuteVolume</span><br><span class=\"line\">/* override */</span><br><span class=\"line\">- (id)initWithMin: (int)a max: (int)b step: (int)s</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tself = [super initWithMin:a max:b step:s];</span><br><span class=\"line\">\tif (self != nil)</span><br><span class=\"line\">\t\tmuting = NO;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* override */</span><br><span class=\"line\">- (int)value</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn muting ? min : val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)mute</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmuting = !muting;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"继承和方法调用\"><a href=\"#继承和方法调用\" class=\"headerlink\" title=\"继承和方法调用\"></a>继承和方法调用</h1><p><strong>使用self调用方法：</strong><br>如果想在一个方法中调用当前类中定义的方法，可以利用self。但如果存在继承关系，通过self调用方法时需要格外注意：<strong>self始终指向收到当前消息的示例变量</strong></p>\n<p><strong>使用super调用方法：</strong><br>super调用的是父类的方法，而至于到底调用了哪个方法则是由编译时类的继承关系决定的。</p>\n<p>我们用一个简单的程序来验证一下上面所描述的内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/NSObject.h&gt;</span><br><span class=\"line\">#import &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface A: NSObject</span><br><span class=\"line\">- (void)method1;</span><br><span class=\"line\">- (void)method2;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation A</span><br><span class=\"line\">- (void)method1 &#123; printf(&quot;method1 of Class A\\n&quot;); &#125;</span><br><span class=\"line\">- (void)method2 &#123; printf(&quot;method2 of Class A\\n&quot;); &#125;</span><br><span class=\"line\">@end </span><br><span class=\"line\"></span><br><span class=\"line\">@interface B : A</span><br><span class=\"line\">- (void)method;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation B</span><br><span class=\"line\">- (void)method2;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation B</span><br><span class=\"line\">- (void)method2 &#123;</span><br><span class=\"line\">\tprintf(&quot;method2 of Class B\\n&quot;);</span><br><span class=\"line\">\tprintf(&quot;self ---&gt; &quot;);</span><br><span class=\"line\">\t[self method1];</span><br><span class=\"line\">\tprintf(&quot;super ---&gt; &quot;);</span><br><span class=\"line\">\t[super method2];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@interface C : B</span><br><span class=\"line\">- (void)method1;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation C</span><br><span class=\"line\">- (void)method1 &#123; printf(&quot;method1 of Class C\\n&quot;); &#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tid x = [[B alloc] init];</span><br><span class=\"line\">\tid y = [[C alloc] init];</span><br><span class=\"line\">\tprintf(&quot;--- instance of B ---- \\n&quot;);</span><br><span class=\"line\">\t[x method1];</span><br><span class=\"line\">\t[x method2];</span><br><span class=\"line\">\tprintf(&quot;--- instance of C --- \\n&quot;);</span><br><span class=\"line\">\t[y method1];</span><br><span class=\"line\">\t[y method2];</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--- instance of B ---</span><br><span class=\"line\">method1 of Class A</span><br><span class=\"line\">method2 of Class B</span><br><span class=\"line\">self --&gt; method1 of Class A</span><br><span class=\"line\">super --&gt; method2 of Class A</span><br><span class=\"line\">--- instance of A ---</span><br><span class=\"line\">method1 of Class C</span><br><span class=\"line\">method2 of Class B</span><br><span class=\"line\">self --&gt; method1 of Class C</span><br><span class=\"line\">super --&gt; method2 of Class A</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"方法定义时的注意事项\"><a href=\"#方法定义时的注意事项\" class=\"headerlink\" title=\"方法定义时的注意事项\"></a>方法定义时的注意事项</h1><h2 id=\"局部方法\"><a href=\"#局部方法\" class=\"headerlink\" title=\"局部方法\"></a>局部方法</h2><p>实现接口声明中的方法时，可以把具备独立功能的部分独立出来定义成子方法。一般情况下，这些方法都只供内部调用，不需要包含在类的接口中对外公开。这些方法，被称为局部方法。局部方法只能在被定义在局部方法之后的方法调用。定义顺序方法出现的问题，可以在后续的[[范畴]]中解决</p>\n","categories":["iOS"],"tags":["Objective-C"]},{"title":"React Native 原架构","url":"/2023/10/06/React%20Native/React%20Native%20%E5%8E%9F%E6%9E%B6%E6%9E%84/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"移动端的发展\"><a href=\"#移动端的发展\" class=\"headerlink\" title=\"移动端的发展\"></a>移动端的发展</h1><p>上世纪 90 年代，3Com 公司的 Palm OS 成为移动领域（掌上电脑）的霸主，市场占有率达 90%。直到 20 世纪末，微软推出了 Windows CE 和 Windows Mobile，取代了 Palm OS。随后，Symbian 和 Blackberry 昙花一现，也曾一度占有 40%的市场。再后来，W3C 立项 HTML5，并于 2008 年 1 月发布 HTML5 第一份正式草案。2007 年 1 月，苹果推出了第一部 iPhone，iOS 系统诞生。同年 11 月，google 宣布推出 Android 系统，并于次年 10 月发布了第一部 Android 智能手机。至此，移动端的基本格局已经奠定。</p>\n<p>2010-2012 年：FaceBook 牵头成立 Moblie Web 工作组，大举进攻移动领域，Web App 的呼声越来越高，一度认为 Native App 在 3 年内会消亡</p>\n<p>2012 年：FaceBook 宣布放弃使用 HTML 5 构造自己的主题应用，HTML 5 进入最惨淡的一年</p>\n<p>2014 年 10 底：HTML5 定稿，迎来了原生+HTML5 的混合开发模式</p>\n<p>2015 年：FackBook 推出 React Native</p>\n<p>2018 年 2 月：Google 发布 Flutter 第一版本</p>\n<p>2018 年 6 月：FaceBook 宣布对 React Native 进行大规模重构，并在 2023 年基本完成重构工作</p>\n<h1 id=\"跨平台方法的对比\"><a href=\"#跨平台方法的对比\" class=\"headerlink\" title=\"跨平台方法的对比\"></a>跨平台方法的对比</h1><blockquote>\n<p>[!question] 为什么要进行跨平台的研究<br>【微观上】：企业要提高开发效率，降低开发成本，实现一次编码，到处运行；【宏观上】：现在处于多端发展时代，多种终端生态互不兼容，造成生产力浪费，势必会有一种新技术代表先进生产力</p>\n</blockquote>\n<h2 id=\"Native-App\"><a href=\"#Native-App\" class=\"headerlink\" title=\"Native App\"></a>Native App</h2><p>第三方应用程序会与平台进行交互，以创建 widgets（组件） 或访问相机等服务。其中 widgets 呈现给屏幕画布，并将事件传回给 widgets</p>\n<p><img src=\"/img/ReactNative/NativeApp%E6%9E%B6%E6%9E%84.png\"></p>\n<h2 id=\"基于-WebView-的第一代跨平台框架\"><a href=\"#基于-WebView-的第一代跨平台框架\" class=\"headerlink\" title=\"基于 WebView 的第一代跨平台框架\"></a>基于 WebView 的第一代跨平台框架</h2><p>第一代跨平台框架基于 JavaScript 和 WebViews，代表者有：PhoneGap，微信小程序。</p>\n<p>第三方应用程序创建 HTML 并将其显示在平台的 WebView 上，对于平台提供的一些系统服务，通过 JS Bridge 来调用。由于这些调用不是很频繁，JS Bridge 并不会成为性能瓶颈。然而，一个完整 HTML5 页面的展示要经历浏览器控件的加载、解析和渲染三大过程，性能消耗要比原生开发增加 N 个数量级，所以这种方案的瓶颈在于 WebView 对于 H5 页面的渲染。这种开发模式开发的 App 既有原生应用代码又有 Web 应用代码，因此又被称为 Hybrid App（混合应用程序）</p>\n<p><img src=\"/img/ReactNative/WebView%E6%9E%B6%E6%9E%84.png\"></p>\n<h2 id=\"以-React-Native-为代表的第二代跨平台框架\"><a href=\"#以-React-Native-为代表的第二代跨平台框架\" class=\"headerlink\" title=\"以 React Native 为代表的第二代跨平台框架\"></a>以 React Native 为代表的第二代跨平台框架</h2><p>这种方案也称为<strong>泛 Web 容器方案</strong> ，这种方案放弃了 WebView 渲染，采用原生自带的 UI 组件代替了核心的渲染引擎，所以这种方案的性能要比第一代方案好很多。代表者就是 RN 、Weex。同时这种方案保持了 JavaScript 作为开发语言，支持前端丰富的生态（比如 RN 使用 React.js 极大地方便了 UI 的创建）。由于前端和 Native 的交互都要通过中间的 Bridge，很自然的 Bridge 就成了这种方案的性能瓶颈<br><img src=\"/img/ReactNative/ReactNative%E6%97%A7%E6%9E%B6%E6%9E%84.png\"></p>\n<h2 id=\"以-Flutter-为代表的第三代跨平台框架\"><a href=\"#以-Flutter-为代表的第三代跨平台框架\" class=\"headerlink\" title=\"以 Flutter 为代表的第三代跨平台框架\"></a>以 Flutter 为代表的第三代跨平台框架</h2><p>为什么说 Flutter 是一种新的方案呢？因为他采用了一种自绘引擎的方式，和以往的方案都不一样；Flutter 既不用 WebView 进行组件渲染，也不适用原生组件进行渲染，他完全自己搞了一套跨平台 UI 渲染框架，渲染引擎依靠跨平台的 Skia 图形库来实现，手机平台只需要提供一块画布即可。同时开发语言使用即支持 JIT 又支持 AOT 的 Dart 语言，即提升了执行效率，也为支持动态化提供可能<br><img src=\"/img/ReactNative/Flutter%E6%9E%B6%E6%9E%84.png\"></p>\n<h1 id=\"ReactNative-架构一览\"><a href=\"#ReactNative-架构一览\" class=\"headerlink\" title=\"ReactNative 架构一览\"></a>ReactNative 架构一览</h1><p>本文基于 React Native 0.54.3 版本 Android 的架构分析</p>\n<p><img src=\"/img/ReactNative/ReactNative%E6%9E%B6%E6%9E%84%E5%B1%82%E7%BA%A7.png\"><br>RN 的老架构主要包含 React、JavaScript、Bridge 和 Native 四个部分。从上到下可以分成四层，分别是 JS 代码层、JS 引擎层、通信层、原生层。最上面的 JS 代码层提供 React.js 支持，React.js 的 JSX 代码转换为 JS 代码运行在 [[JavaScriptCore]] 提供的 JavaScript 运行时环境中，通信层将 JavaScript 与 Native 层连接起来；通信层又分为三部分，其中 Shadow Tree 用来定义 UI 效果及交互功能、Native Modules 提供 Native 功能（比如相册、蓝牙等）、而他们之间的相互通信使用的是 JSON 异步消息</p>\n<p>基于上述架构，RN 运行时创建三个线程：</p>\n<ul>\n<li>「<strong>JS Thread</strong>」： 主要负责 React，JS 的执行，输出 App 的视图信息（结构、样式、属性等）</li>\n<li>「<strong>Shadow Thread</strong>」：根据 JS 线程的视图信息，创建出用于布局计算的 ShadowTree；（主要用到 UIManagerModule，是 RN 中非常重要的 Native Module，故也叫做 Native Module Thread）</li>\n<li>「<strong>Main Thead</strong>」：根据 ShadowTree 提供的完整试图信息，负责真实 Native View 的创建<br>下面，将分为启动流程、渲染原理、通信机制三个部分详细剖析一下 RN 的实现原理</li>\n</ul>\n<h1 id=\"启动流程\"><a href=\"#启动流程\" class=\"headerlink\" title=\"启动流程\"></a>启动流程</h1><p>总结起来，启动流程主要做了两件事：一件是准备环境，一件事调用 JS 侧的入口函数<br>准备环境：在后台创建上下文、初始化通信桥、加载 JSBundle、初始化 JS 执行环境。<br>调用 JS 侧的入口函数：即调用 Appregistry.js 的 runApplication 方法，为一次 Native 到 JS 的调用</p>\n<p><img src=\"/img/ReactNative/RN%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png\"></p>\n<h1 id=\"渲染原理\"><a href=\"#渲染原理\" class=\"headerlink\" title=\"渲染原理\"></a>渲染原理</h1><p><img src=\"/img/ReactNative/RN%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.png\"></p>\n<p>RN 运行时会创建三个线程：JS Thread、Shadow Thread、Main Thread，在这三个线程中分别会创建三棵树，JS 线程中会创建一棵叫做<strong>Fiber Tree</strong>，在 Shadow 线程中会创建一棵树叫做<strong>Shadow Tree</strong>，在 UI 线程中则是 <strong>View Tree</strong> 。其中，Fiber Tree 在 JS 侧创建，Shadow Tree 和 View Tree 在 Native 测创建，RN 渲染机制的重点就是这三棵树的创建和同步，关键步骤如下：</p>\n<p><img src=\"/img/ReactNative/RN%E6%B8%B2%E6%9F%93Tree%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%8C%E6%AD%A5.png\"></p>\n<ol>\n<li><strong>第一步：</strong> 通过 React.js 的 JSX 定义 UI 结构</li>\n<li><strong>第二步：</strong> 编译阶段，通过 Babel 将 JSX 转化为 React.createElement 的形态</li>\n<li><strong>第三步：</strong> 在 JS 侧，通过深度优先遍历将 JSX 编写的 UI 组件转换为 Fiber Tree 结构，每个组件节点都包含子组件、父组件和兄弟组件的引用</li>\n<li><strong>第四步：</strong> JS 侧在创建 Fiber Tree 各个节点的时候会通过 Bridge 桥向 Native 侧发送对应的指令。Native 侧收到这些指令之后会创建对应的 Shadow Tree 节点，同时会生成对应的 UIViewOperation，加入到 UIViewOperationQueue 中，以供 UI 线程进行真正的 UI 操作。JS 侧发送完一批 UI 指令之后会触发 Native 侧的 onBatchComplete 回调，进而后续遍历 ShadowTree，分别计算每个节点的宽度和高度，然后前序遍历 ShadowTree，确定每个节点的最终位置，生成相应的 UpdateLayoutOperation，加入到 UIViewOperationQueue 中</li>\n<li><strong>第五步：</strong> 出发 FrameCallback，从 UIViewOperationQueue 中依次取出 UIViewOperation，生成对应的 View Tree，挂载到 RootView，进行原生 UI 渲染逻辑</li>\n</ol>\n<blockquote>\n<p>[!question]- 虚节点和 Layout Only 节点区别？</p>\n<ol>\n<li>虚节点在计算布局时会被忽略，也不会生成相应的 Native 节点</li>\n<li>LayoutOnly 节点指一个节点只会影响到它的子节点的位置，而本身不需要绘制任何内容，那么这个节点就是 LayoutOnly 节点，也不会生成相应的 Native 控件</li>\n</ol>\n</blockquote>\n<h1 id=\"通信机制\"><a href=\"#通信机制\" class=\"headerlink\" title=\"通信机制\"></a>通信机制</h1><p><img src=\"/img/ReactNative/RN%E5%8E%9F%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.png\"><br>在 RN 中有三个线程：JS 线程、UI 线程、Shadow 线程（即 Native Modules 线程），而在 Native Modules 线程中，主要用于进行 Yoga 布局计算，同时也负责 C++层和原生通信。我们知道 Java 可以通过 JNI 的方式和 C++代码实现相互调用，而 Objective-C 可以直接调用 C++代码。JS 可以通过 [[JavaScriptCore]] 实现和 C++的相互调用，而 JavaScriptCore 是由 C++实现的 JS 引擎，所以很自然的，C++就成为了连接原生和 JS 的桥梁。</p>\n<p>所以 RN 的通信机制总结起来就是一句话：<strong>一个 C++实现的 bridge (桥)打通了原生和 JS，实现了两者的相互调用</strong></p>\n<h2 id=\"桥的初始化\"><a href=\"#桥的初始化\" class=\"headerlink\" title=\"桥的初始化\"></a>桥的初始化</h2><p>在 RN 的启动流程中，会对通信桥进行初始化。通信桥的初始化最关键的就是创建两张表和建立两个桥。两张表中，一张是 JavaScriptModuleRegistry，供原生调用 JS 使用，一张是 NativeModuleRegistry，供 JS 调用原生使用；两个桥中，一个是 NativeToJSBridge，是原生调用 JS 的桥梁，一个是 JSToNativeBridge，JS 调用原生的桥梁。</p>\n<h2 id=\"Native-调用-JS\"><a href=\"#Native-调用-JS\" class=\"headerlink\" title=\"Native 调用 JS\"></a>Native 调用 JS</h2><p>Native 调用 JS 的流程相对简单：</p>\n<p><img src=\"/img/ReactNative/RNNative%E8%B0%83%E7%94%A8JS.png\"></p>\n<ol>\n<li>在 Java 层把要实现的功能编写成接口并继承 JavaScriptModule，并交由 ReactPackage 管理，最终会在RN初始化的时候添加到JavaScriptModuleRegistry注册表中</li>\n<li>JavaScriptModuleRegistry通过动态代理生成对应的JavaScriptModule，然后通过invoke()调用相应的JS方法，该方法会进一步去调用CatalystInstanceImpl.callJSFunction，该方法会通过JNI将相关参数传递到C++层</li>\n<li>C++层通过NativeToJsBridge将callFunction的消息放入消息队列等待执行；C++层中保有MessageQueue中的一些属性对象，通过这些属性对象进入JS层</li>\n<li>在JS层里，找到对应的JavaScriptModule及方法执行</li>\n</ol>\n<h2 id=\"JS调用Native\"><a href=\"#JS调用Native\" class=\"headerlink\" title=\"JS调用Native\"></a>JS调用Native</h2><p>在JSToNative的通信方式中，又分为两种调用方式：</p>\n<ul>\n<li>「异步调用」：指的是在JSToNative的通信方式中，调用的发起在JS线程，逻辑处理和计算在Native Module线程和UI线程，异步的方式不会阻塞JS线程</li>\n<li>「同步调用」：指的是调用和处理过程都发生在JS线程中；如果逻辑计算简单，这没什么影响，但是如果逻辑计算复杂，那肯定得卡死JS线程。</li>\n</ul>\n<p><img src=\"/img/ReactNative/JSCallbackRN.png\"><br>整个流程可以分为两个部分，第一个部分是JS调用Native，第二个部分是Native将执行结果回调至JS侧（和Native调用JS的流程很相似）<br>JS调用Native流程如下：</p>\n<ol>\n<li>从JS侧进入C++层，通过JSC桥接获取Java Module的注册表，然后回到JS侧，将它转换为对应的JS Native  Module，并根据不同的调用类型，将xxMethod的调用封装成消息，放入MessageQueue的队列里</li>\n<li>xxMethod消息处理的时候，会进入C++层，拿到对应的module信息，通过JSToNativeBridge，将该函数调用消息放到线程的消息队列中等待执行。此时C++层的函数调用会映射为同名的Java层JavaModuleWrapper对象，并调用其中的invoke方法，传入的参数是methodId和对应的参数信息</li>\n<li>Java层的JavaModuleWrapper对象，根据参数信息，找到对应的JavaMethodWrapper对象，再执行其invoke方法，通过反射调用对应的NativeModule，从而完成JS到Native的调用</li>\n</ol>\n<h1 id=\"性能瓶颈与新架构\"><a href=\"#性能瓶颈与新架构\" class=\"headerlink\" title=\"性能瓶颈与新架构\"></a>性能瓶颈与新架构</h1><p>基于此架构，中间层Bridge必然成为RN的性能瓶颈，其存在以下问题：</p>\n<ol>\n<li>通信效率低下，容易出现堵塞<blockquote>\n<p>JS层和Native层只能通过桥来通信，多次线程切换、串行消息处理、参数通过JSON序列化和反序列化传递，导致效率低下，容易出现堵塞</p>\n</blockquote>\n</li>\n<li>异步调用导致不能同步响应，用户体验差<blockquote>\n<p>受限制于通信机制，RN里JS和Native侧相互之间只能异步调用，用户的操作和APP的响应是异步的，且之间可能会有不小的延迟，用户体验不佳</p>\n</blockquote>\n</li>\n</ol>\n<p>而新架构将解决这些问题，新架构的主要内容有：</p>\n<ul>\n<li>JSI： 增加引擎抽象层，实现引擎解耦，同时支持JS持有C++ HostObject类型对象引用，实现JS和Native的相会感知</li>\n<li>TurboModule：重构后的NativeModules，用于向前端暴露Native能力，实现NativeModule的按需加载和JS与Native的同步调用</li>\n</ul>\n","categories":["前端"],"tags":["ReactNative"]},{"title":"如何成为一名优秀的跨端开发","url":"/2023/12/08/Other/%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E4%BC%98%E7%A7%80%E7%9A%84%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>本文将列出我认为的一名优秀的跨端开发所需掌握了解的知识点，涵盖前端，跨端架构，iOS端，Android端、C++底层以及计算机网络、操作系统、数据结构、算法、编译原理等核心基础。本文会根据后续自身的技术栈扩展而更新</p>\n<h1 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h1><h2 id=\"JavaScript与ECAMScript标准\"><a href=\"#JavaScript与ECAMScript标准\" class=\"headerlink\" title=\"JavaScript与ECAMScript标准\"></a>JavaScript与ECAMScript标准</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 作用域与闭包</li>\n<li><input disabled=\"\" type=\"checkbox\"> this和对象原型</li>\n<li><input disabled=\"\" type=\"checkbox\"> 类型和语法</li>\n<li><input disabled=\"\" type=\"checkbox\"> 异步与性能</li>\n<li><input disabled=\"\" type=\"checkbox\"> 箭头函数</li>\n<li><input disabled=\"\" type=\"checkbox\"> 扩展运算符与解构</li>\n<li><input disabled=\"\" type=\"checkbox\"> 模版语法</li>\n<li><input disabled=\"\" type=\"checkbox\"> new操作符与实现原理</li>\n<li><input disabled=\"\" type=\"checkbox\"> map与set</li>\n<li><input disabled=\"\" type=\"checkbox\"> 类数组</li>\n<li><input disabled=\"\" type=\"checkbox\"> Ajax、Fetch和Axios请求</li>\n<li><input disabled=\"\" type=\"checkbox\"> ES6模块、CommonJS模块和amd</li>\n<li><input disabled=\"\" type=\"checkbox\"> async&#x2F;await</li>\n<li><input disabled=\"\" type=\"checkbox\"> 防抖与节流</li>\n<li><input disabled=\"\" type=\"checkbox\"> 垃圾回收与内存泄漏</li>\n<li><input disabled=\"\" type=\"checkbox\"> ES6-10新规范</li>\n</ul>\n<h2 id=\"React与Redux\"><a href=\"#React与Redux\" class=\"headerlink\" title=\"React与Redux\"></a>React与Redux</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 事件机制与代理</li>\n<li><input disabled=\"\" type=\"checkbox\"> 常见Hook与原理（useCallback和useMemo）</li>\n<li><input disabled=\"\" type=\"checkbox\"> 函数式编程与函数柯里化</li>\n<li><input disabled=\"\" type=\"checkbox\"> 高阶组件</li>\n<li><input disabled=\"\" type=\"checkbox\"> 生命周期</li>\n<li><input disabled=\"\" type=\"checkbox\"> 重渲染机制</li>\n<li><input disabled=\"\" type=\"checkbox\"> 无状态组件</li>\n<li><input disabled=\"\" type=\"checkbox\"> Context的理解</li>\n<li><input disabled=\"\" type=\"checkbox\"> 受控与非受控组件</li>\n<li><input disabled=\"\" type=\"checkbox\"> ref与forwardRef</li>\n<li><input disabled=\"\" type=\"checkbox\"> 类组件与函数式组件</li>\n<li><input disabled=\"\" type=\"checkbox\"> 类组件的生命周期</li>\n<li><input disabled=\"\" type=\"checkbox\"> setState深入理解</li>\n<li><input disabled=\"\" type=\"checkbox\"> 组件间通信</li>\n<li><input disabled=\"\" type=\"checkbox\"> Redux原理与工作流</li>\n<li><input disabled=\"\" type=\"checkbox\"> Redux中间件</li>\n<li><input disabled=\"\" type=\"checkbox\"> Redux异步处理</li>\n<li><input disabled=\"\" type=\"checkbox\"> Redux与Mobx</li>\n<li><input disabled=\"\" type=\"checkbox\"> React虚拟DOM(暂定)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Fiber树(暂定)</li>\n<li><input disabled=\"\" type=\"checkbox\"> React Diff算法(暂定)</li>\n</ul>\n<h2 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 常见类型</li>\n<li><input disabled=\"\" type=\"checkbox\"> 类型收窄</li>\n<li><input disabled=\"\" type=\"checkbox\"> 函数与对象类型</li>\n<li><input disabled=\"\" type=\"checkbox\"> 泛型</li>\n<li><input disabled=\"\" type=\"checkbox\"> Keyof与Typeof</li>\n<li><input disabled=\"\" type=\"checkbox\"> 索引访问</li>\n<li><input disabled=\"\" type=\"checkbox\"> 条件类型</li>\n<li><input disabled=\"\" type=\"checkbox\"> 映射类型</li>\n<li><input disabled=\"\" type=\"checkbox\"> 模版字面量类型</li>\n<li><input disabled=\"\" type=\"checkbox\"> 类</li>\n<li><input disabled=\"\" type=\"checkbox\"> 模块</li>\n</ul>\n<h1 id=\"跨端\"><a href=\"#跨端\" class=\"headerlink\" title=\"跨端\"></a>跨端</h1><h2 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> React Native原生模块</li>\n<li><input disabled=\"\" type=\"checkbox\"> React Native原生组件</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> React Native 0.70前架构</li>\n<li><input disabled=\"\" type=\"checkbox\"> React Native新架构</li>\n<li><input disabled=\"\" type=\"checkbox\"> JSI理解</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 跨端架构横向对比</li>\n<li><input disabled=\"\" type=\"checkbox\"> JSBridge理解</li>\n<li><input disabled=\"\" type=\"checkbox\"> JSCore理解</li>\n<li><input disabled=\"\" type=\"checkbox\"> WASM技术</li>\n<li><input disabled=\"\" type=\"checkbox\"> 了解H5和Hybrid</li>\n<li><input disabled=\"\" type=\"checkbox\"> 了解Flutter与RN的主要区别</li>\n</ul>\n<h1 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h1><h2 id=\"Objective-C基础\"><a href=\"#Objective-C基础\" class=\"headerlink\" title=\"Objective-C基础\"></a>Objective-C基础</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 类和继承</li>\n<li><input disabled=\"\" type=\"checkbox\"> 对象的类型和动态绑定</li>\n<li><input disabled=\"\" type=\"checkbox\"> 基于引用计数的内存管理</li>\n<li><input disabled=\"\" type=\"checkbox\"> 垃圾回收</li>\n<li><input disabled=\"\" type=\"checkbox\"> 属性声明</li>\n<li><input disabled=\"\" type=\"checkbox\"> 类NSObjet和运行时系统</li>\n<li><input disabled=\"\" type=\"checkbox\"> Foundation框架中常用的类</li>\n<li><input disabled=\"\" type=\"checkbox\"> 范畴</li>\n<li><input disabled=\"\" type=\"checkbox\"> 抽象类和类簇</li>\n<li><input disabled=\"\" type=\"checkbox\"> 协议</li>\n<li><input disabled=\"\" type=\"checkbox\"> 对象的复制与存储</li>\n<li><input disabled=\"\" type=\"checkbox\"> 块对象</li>\n<li><input disabled=\"\" type=\"checkbox\"> 消息发送模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 应用的构造</li>\n<li><input disabled=\"\" type=\"checkbox\"> 异常和错误</li>\n<li><input disabled=\"\" type=\"checkbox\"> 并行编程</li>\n<li><input disabled=\"\" type=\"checkbox\"> 键值编码</li>\n</ul>\n<h2 id=\"核心知识点\"><a href=\"#核心知识点\" class=\"headerlink\" title=\"核心知识点\"></a>核心知识点</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> OC对象的本质</li>\n<li><input disabled=\"\" type=\"checkbox\"> Class的本质</li>\n<li><input disabled=\"\" type=\"checkbox\"> KVO本质</li>\n<li><input disabled=\"\" type=\"checkbox\"> isa和Class</li>\n<li><input disabled=\"\" type=\"checkbox\"> 消息发送与转发</li>\n<li><input disabled=\"\" type=\"checkbox\"> Runtime</li>\n<li><input disabled=\"\" type=\"checkbox\"> RunLoop</li>\n<li><input disabled=\"\" type=\"checkbox\"> KVC解析</li>\n<li><input disabled=\"\" type=\"checkbox\"> Category</li>\n<li><input disabled=\"\" type=\"checkbox\"> Block捕获外部变量和__block原理</li>\n<li><input disabled=\"\" type=\"checkbox\"> weak实现原理</li>\n<li><input disabled=\"\" type=\"checkbox\"> NSArray的底层实现</li>\n<li><input disabled=\"\" type=\"checkbox\"> AutoreleasePool及其实现原理</li>\n<li><input disabled=\"\" type=\"checkbox\"> 深入浅出GCD</li>\n<li><input disabled=\"\" type=\"checkbox\"> iOS多线程的线程锁</li>\n<li><input disabled=\"\" type=\"checkbox\"> NSOperation的进阶使用</li>\n<li><input disabled=\"\" type=\"checkbox\"> Bonjour</li>\n<li><input disabled=\"\" type=\"checkbox\"> SDWebImage</li>\n<li><input disabled=\"\" type=\"checkbox\"> WebSocket</li>\n<li><input disabled=\"\" type=\"checkbox\"> Effective Objective-C</li>\n</ul>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h1><h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> const</li>\n<li><input disabled=\"\" type=\"checkbox\"> static</li>\n<li><input disabled=\"\" type=\"checkbox\"> this指针</li>\n<li><input disabled=\"\" type=\"checkbox\"> inline内联函数</li>\n<li><input disabled=\"\" type=\"checkbox\"> assert</li>\n<li><input disabled=\"\" type=\"checkbox\"> sizeof</li>\n<li><input disabled=\"\" type=\"checkbox\"> #pragma pack</li>\n<li><input disabled=\"\" type=\"checkbox\"> 位域</li>\n<li><input disabled=\"\" type=\"checkbox\"> volatile</li>\n<li><input disabled=\"\" type=\"checkbox\"> auto</li>\n<li><input disabled=\"\" type=\"checkbox\"> struct和typedef struct</li>\n<li><input disabled=\"\" type=\"checkbox\"> struct和class</li>\n<li><input disabled=\"\" type=\"checkbox\"> union联合</li>\n<li><input disabled=\"\" type=\"checkbox\"> explicit(显示)构造函数</li>\n<li><input disabled=\"\" type=\"checkbox\"> friend友元类和友元函数</li>\n<li><input disabled=\"\" type=\"checkbox\"> using</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>::</code>范围解析符</li>\n<li><input disabled=\"\" type=\"checkbox\"> enum枚举类型</li>\n<li><input disabled=\"\" type=\"checkbox\"> decltype</li>\n<li><input disabled=\"\" type=\"checkbox\"> 左值与右值</li>\n<li><input disabled=\"\" type=\"checkbox\"> 引用</li>\n<li><input disabled=\"\" type=\"checkbox\"> 宏</li>\n<li><input disabled=\"\" type=\"checkbox\"> 成员初始化列表</li>\n<li><input disabled=\"\" type=\"checkbox\"> 封装、继承和多态</li>\n<li><input disabled=\"\" type=\"checkbox\"> 析构函数</li>\n<li><input disabled=\"\" type=\"checkbox\"> 虚函数与纯虚函数</li>\n<li><input disabled=\"\" type=\"checkbox\"> 虚函数指针与虚函数表</li>\n<li><input disabled=\"\" type=\"checkbox\"> 模版类、成员模版</li>\n<li><input disabled=\"\" type=\"checkbox\"> 抽象类、接口类和聚合类</li>\n<li><input disabled=\"\" type=\"checkbox\"> 内存分配与管理</li>\n</ul>\n<h2 id=\"C-11\"><a href=\"#C-11\" class=\"headerlink\" title=\"C++11\"></a>C++11</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> move</li>\n<li><input disabled=\"\" type=\"checkbox\"> shared_ptr</li>\n<li><input disabled=\"\" type=\"checkbox\"> weak_ptr</li>\n<li><input disabled=\"\" type=\"checkbox\"> unique_ptr</li>\n<li><input disabled=\"\" type=\"checkbox\"> auto_ptr</li>\n</ul>\n<h2 id=\"STL\"><a href=\"#STL\" class=\"headerlink\" title=\"STL\"></a>STL</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 索引</li>\n<li><input disabled=\"\" type=\"checkbox\"> 容器</li>\n<li><input disabled=\"\" type=\"checkbox\"> 算法</li>\n</ul>\n<h1 id=\"基础-1\"><a href=\"#基础-1\" class=\"headerlink\" title=\"基础\"></a>基础</h1><h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> TCP</li>\n<li><input disabled=\"\" type=\"checkbox\"> UDP</li>\n<li><input disabled=\"\" type=\"checkbox\"> TCP和UDP的区别</li>\n<li><input disabled=\"\" type=\"checkbox\"> TCP的传输连接管理</li>\n<li><input disabled=\"\" type=\"checkbox\"> TCP的流量和拥塞控制</li>\n<li><input disabled=\"\" type=\"checkbox\"> DNS</li>\n<li><input disabled=\"\" type=\"checkbox\"> MDNS</li>\n<li><input disabled=\"\" type=\"checkbox\"> HTTP协议</li>\n<li><input disabled=\"\" type=\"checkbox\"> HTTPS协议</li>\n<li><input disabled=\"\" type=\"checkbox\"> HTTP协议与</li>\n<li><input disabled=\"\" type=\"checkbox\"> Socket连接</li>\n<li><input disabled=\"\" type=\"checkbox\"> WebRTC</li>\n</ul>\n<h2 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 链表</li>\n<li><input disabled=\"\" type=\"checkbox\"> 队列</li>\n<li><input disabled=\"\" type=\"checkbox\"> 栈</li>\n<li><input disabled=\"\" type=\"checkbox\"> 树</li>\n<li><input disabled=\"\" type=\"checkbox\"> 排序算法</li>\n<li><input disabled=\"\" type=\"checkbox\"> 搜索算法</li>\n<li><input disabled=\"\" type=\"checkbox\"> 深度优先</li>\n<li><input disabled=\"\" type=\"checkbox\"> 广度优先</li>\n<li><input disabled=\"\" type=\"checkbox\"> 动态规划</li>\n<li><input disabled=\"\" type=\"checkbox\"> 贪心算法</li>\n<li><input disabled=\"\" type=\"checkbox\"> 回溯算法</li>\n<li><input disabled=\"\" type=\"checkbox\"> 分治算法</li>\n</ul>\n<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 观察者模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 装饰器模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 工厂模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 单例模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 命令模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 适配器与外观模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 模版方法模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 迭代器和组合模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 状态模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 代理模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 复合模式</li>\n</ul>\n<h2 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 常见指令</li>\n<li><input disabled=\"\" type=\"checkbox\"> 分支管理</li>\n<li><input disabled=\"\" type=\"checkbox\"> github action</li>\n</ul>\n<h1 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h1><p><strong>参考书籍与博客:</strong></p>\n<ul>\n<li>《你不知道的JavaScript》</li>\n<li><a href=\"https://juejin.cn/post/6940945178899251230?searchId=202311132204230AA4361F743361752A38\">高频前端面试题汇总</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog\">冴羽的博客</a></li>\n<li><a href=\"https://juejin.cn/post/6844903975930576903?from=search-suggest\">iOS学习栈</a></li>\n<li><a href=\"https://juejin.cn/post/6844903829796814861?searchId=20231208175256AC468E4F17F5B1AE6390\">五万字长文 C C++ 面试知识总结（上）</a></li>\n<li><a href=\"https://juejin.cn/post/6900698814093459463?searchId=202312081742232FAED81543052C9BA107#heading-10\">「算法与数据结构」你可能需要的一份前端算法总结</a></li>\n<li>《Head First设计模式》</li>\n</ul>\n","categories":["其他"],"tags":["计划"]}]