[{"title":"如何成为一名优秀的跨端开发","url":"/2023/12/08/Other/%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E4%BC%98%E7%A7%80%E7%9A%84%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>本文将列出我认为的一名优秀的跨端开发所需掌握了解的知识点，涵盖前端，跨端架构，iOS端，Android端、C++底层以及计算机网络、操作系统、数据结构、算法、编译原理等核心基础。本文会根据后续自身的技术栈扩展而更新</p>\n<h1 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h1><h2 id=\"JavaScript与ECAMScript标准\"><a href=\"#JavaScript与ECAMScript标准\" class=\"headerlink\" title=\"JavaScript与ECAMScript标准\"></a>JavaScript与ECAMScript标准</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 作用域与闭包</li>\n<li><input disabled=\"\" type=\"checkbox\"> this和对象原型</li>\n<li><input disabled=\"\" type=\"checkbox\"> 类型和语法</li>\n<li><input disabled=\"\" type=\"checkbox\"> 异步与性能</li>\n<li><input disabled=\"\" type=\"checkbox\"> 箭头函数</li>\n<li><input disabled=\"\" type=\"checkbox\"> 扩展运算符与解构</li>\n<li><input disabled=\"\" type=\"checkbox\"> 模版语法</li>\n<li><input disabled=\"\" type=\"checkbox\"> new操作符与实现原理</li>\n<li><input disabled=\"\" type=\"checkbox\"> map与set</li>\n<li><input disabled=\"\" type=\"checkbox\"> 类数组</li>\n<li><input disabled=\"\" type=\"checkbox\"> Ajax、Fetch和Axios请求</li>\n<li><input disabled=\"\" type=\"checkbox\"> ES6模块、CommonJS模块和amd</li>\n<li><input disabled=\"\" type=\"checkbox\"> async&#x2F;await</li>\n<li><input disabled=\"\" type=\"checkbox\"> 防抖与节流</li>\n<li><input disabled=\"\" type=\"checkbox\"> 垃圾回收与内存泄漏</li>\n<li><input disabled=\"\" type=\"checkbox\"> ES6-10新规范</li>\n</ul>\n<h2 id=\"React与Redux\"><a href=\"#React与Redux\" class=\"headerlink\" title=\"React与Redux\"></a>React与Redux</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 事件机制与代理</li>\n<li><input disabled=\"\" type=\"checkbox\"> 常见Hook与原理（useCallback和useMemo）</li>\n<li><input disabled=\"\" type=\"checkbox\"> 函数式编程与函数柯里化</li>\n<li><input disabled=\"\" type=\"checkbox\"> 高阶组件</li>\n<li><input disabled=\"\" type=\"checkbox\"> 生命周期</li>\n<li><input disabled=\"\" type=\"checkbox\"> 重渲染机制</li>\n<li><input disabled=\"\" type=\"checkbox\"> 无状态组件</li>\n<li><input disabled=\"\" type=\"checkbox\"> Context的理解</li>\n<li><input disabled=\"\" type=\"checkbox\"> 受控与非受控组件</li>\n<li><input disabled=\"\" type=\"checkbox\"> ref与forwardRef</li>\n<li><input disabled=\"\" type=\"checkbox\"> 类组件与函数式组件</li>\n<li><input disabled=\"\" type=\"checkbox\"> 类组件的生命周期</li>\n<li><input disabled=\"\" type=\"checkbox\"> setState深入理解</li>\n<li><input disabled=\"\" type=\"checkbox\"> 组件间通信</li>\n<li><input disabled=\"\" type=\"checkbox\"> Redux原理与工作流</li>\n<li><input disabled=\"\" type=\"checkbox\"> Redux中间件</li>\n<li><input disabled=\"\" type=\"checkbox\"> Redux异步处理</li>\n<li><input disabled=\"\" type=\"checkbox\"> Redux与Mobx</li>\n<li><input disabled=\"\" type=\"checkbox\"> React虚拟DOM(暂定)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Fiber树(暂定)</li>\n<li><input disabled=\"\" type=\"checkbox\"> React Diff算法(暂定)</li>\n</ul>\n<h2 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 常见类型</li>\n<li><input disabled=\"\" type=\"checkbox\"> 类型收窄</li>\n<li><input disabled=\"\" type=\"checkbox\"> 函数与对象类型</li>\n<li><input disabled=\"\" type=\"checkbox\"> 泛型</li>\n<li><input disabled=\"\" type=\"checkbox\"> Keyof与Typeof</li>\n<li><input disabled=\"\" type=\"checkbox\"> 索引访问</li>\n<li><input disabled=\"\" type=\"checkbox\"> 条件类型</li>\n<li><input disabled=\"\" type=\"checkbox\"> 映射类型</li>\n<li><input disabled=\"\" type=\"checkbox\"> 模版字面量类型</li>\n<li><input disabled=\"\" type=\"checkbox\"> 类</li>\n<li><input disabled=\"\" type=\"checkbox\"> 模块</li>\n</ul>\n<h1 id=\"跨端\"><a href=\"#跨端\" class=\"headerlink\" title=\"跨端\"></a>跨端</h1><h2 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> React Native原生模块</li>\n<li><input disabled=\"\" type=\"checkbox\"> React Native原生组件</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> React Native 0.70前架构</li>\n<li><input disabled=\"\" type=\"checkbox\"> React Native新架构</li>\n<li><input disabled=\"\" type=\"checkbox\"> JSI理解</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 跨端架构横向对比</li>\n<li><input disabled=\"\" type=\"checkbox\"> JSBridge理解</li>\n<li><input disabled=\"\" type=\"checkbox\"> JSCore理解</li>\n<li><input disabled=\"\" type=\"checkbox\"> WASM技术</li>\n<li><input disabled=\"\" type=\"checkbox\"> 了解H5和Hybrid</li>\n<li><input disabled=\"\" type=\"checkbox\"> 了解Flutter与RN的主要区别</li>\n</ul>\n<h1 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h1><h2 id=\"Objective-C基础\"><a href=\"#Objective-C基础\" class=\"headerlink\" title=\"Objective-C基础\"></a>Objective-C基础</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 类和继承</li>\n<li><input disabled=\"\" type=\"checkbox\"> 对象的类型和动态绑定</li>\n<li><input disabled=\"\" type=\"checkbox\"> 基于引用计数的内存管理</li>\n<li><input disabled=\"\" type=\"checkbox\"> 垃圾回收</li>\n<li><input disabled=\"\" type=\"checkbox\"> 属性声明</li>\n<li><input disabled=\"\" type=\"checkbox\"> 类NSObjet和运行时系统</li>\n<li><input disabled=\"\" type=\"checkbox\"> Foundation框架中常用的类</li>\n<li><input disabled=\"\" type=\"checkbox\"> 范畴</li>\n<li><input disabled=\"\" type=\"checkbox\"> 抽象类和类簇</li>\n<li><input disabled=\"\" type=\"checkbox\"> 协议</li>\n<li><input disabled=\"\" type=\"checkbox\"> 对象的复制与存储</li>\n<li><input disabled=\"\" type=\"checkbox\"> 块对象</li>\n<li><input disabled=\"\" type=\"checkbox\"> 消息发送模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 应用的构造</li>\n<li><input disabled=\"\" type=\"checkbox\"> 异常和错误</li>\n<li><input disabled=\"\" type=\"checkbox\"> 并行编程</li>\n<li><input disabled=\"\" type=\"checkbox\"> 键值编码</li>\n</ul>\n<h2 id=\"核心知识点\"><a href=\"#核心知识点\" class=\"headerlink\" title=\"核心知识点\"></a>核心知识点</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> OC对象的本质</li>\n<li><input disabled=\"\" type=\"checkbox\"> Class的本质</li>\n<li><input disabled=\"\" type=\"checkbox\"> KVO本质</li>\n<li><input disabled=\"\" type=\"checkbox\"> isa和Class</li>\n<li><input disabled=\"\" type=\"checkbox\"> 消息发送与转发</li>\n<li><input disabled=\"\" type=\"checkbox\"> Runtime</li>\n<li><input disabled=\"\" type=\"checkbox\"> RunLoop</li>\n<li><input disabled=\"\" type=\"checkbox\"> KVC解析</li>\n<li><input disabled=\"\" type=\"checkbox\"> Category</li>\n<li><input disabled=\"\" type=\"checkbox\"> Block捕获外部变量和__block原理</li>\n<li><input disabled=\"\" type=\"checkbox\"> weak实现原理</li>\n<li><input disabled=\"\" type=\"checkbox\"> NSArray的底层实现</li>\n<li><input disabled=\"\" type=\"checkbox\"> AutoreleasePool及其实现原理</li>\n<li><input disabled=\"\" type=\"checkbox\"> 深入浅出GCD</li>\n<li><input disabled=\"\" type=\"checkbox\"> iOS多线程的线程锁</li>\n<li><input disabled=\"\" type=\"checkbox\"> NSOperation的进阶使用</li>\n<li><input disabled=\"\" type=\"checkbox\"> Bonjour</li>\n<li><input disabled=\"\" type=\"checkbox\"> SDWebImage</li>\n<li><input disabled=\"\" type=\"checkbox\"> WebSocket</li>\n<li><input disabled=\"\" type=\"checkbox\"> Effective Objective-C</li>\n</ul>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h1><h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> const</li>\n<li><input disabled=\"\" type=\"checkbox\"> static</li>\n<li><input disabled=\"\" type=\"checkbox\"> this指针</li>\n<li><input disabled=\"\" type=\"checkbox\"> inline内联函数</li>\n<li><input disabled=\"\" type=\"checkbox\"> assert</li>\n<li><input disabled=\"\" type=\"checkbox\"> sizeof</li>\n<li><input disabled=\"\" type=\"checkbox\"> #pragma pack</li>\n<li><input disabled=\"\" type=\"checkbox\"> 位域</li>\n<li><input disabled=\"\" type=\"checkbox\"> volatile</li>\n<li><input disabled=\"\" type=\"checkbox\"> auto</li>\n<li><input disabled=\"\" type=\"checkbox\"> struct和typedef struct</li>\n<li><input disabled=\"\" type=\"checkbox\"> struct和class</li>\n<li><input disabled=\"\" type=\"checkbox\"> union联合</li>\n<li><input disabled=\"\" type=\"checkbox\"> explicit(显示)构造函数</li>\n<li><input disabled=\"\" type=\"checkbox\"> friend友元类和友元函数</li>\n<li><input disabled=\"\" type=\"checkbox\"> using</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>::</code>范围解析符</li>\n<li><input disabled=\"\" type=\"checkbox\"> enum枚举类型</li>\n<li><input disabled=\"\" type=\"checkbox\"> decltype</li>\n<li><input disabled=\"\" type=\"checkbox\"> 左值与右值</li>\n<li><input disabled=\"\" type=\"checkbox\"> 引用</li>\n<li><input disabled=\"\" type=\"checkbox\"> 宏</li>\n<li><input disabled=\"\" type=\"checkbox\"> 成员初始化列表</li>\n<li><input disabled=\"\" type=\"checkbox\"> 封装、继承和多态</li>\n<li><input disabled=\"\" type=\"checkbox\"> 析构函数</li>\n<li><input disabled=\"\" type=\"checkbox\"> 虚函数与纯虚函数</li>\n<li><input disabled=\"\" type=\"checkbox\"> 虚函数指针与虚函数表</li>\n<li><input disabled=\"\" type=\"checkbox\"> 模版类、成员模版</li>\n<li><input disabled=\"\" type=\"checkbox\"> 抽象类、接口类和聚合类</li>\n<li><input disabled=\"\" type=\"checkbox\"> 内存分配与管理</li>\n</ul>\n<h2 id=\"C-11\"><a href=\"#C-11\" class=\"headerlink\" title=\"C++11\"></a>C++11</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> move</li>\n<li><input disabled=\"\" type=\"checkbox\"> shared_ptr</li>\n<li><input disabled=\"\" type=\"checkbox\"> weak_ptr</li>\n<li><input disabled=\"\" type=\"checkbox\"> unique_ptr</li>\n<li><input disabled=\"\" type=\"checkbox\"> auto_ptr</li>\n</ul>\n<h2 id=\"STL\"><a href=\"#STL\" class=\"headerlink\" title=\"STL\"></a>STL</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 索引</li>\n<li><input disabled=\"\" type=\"checkbox\"> 容器</li>\n<li><input disabled=\"\" type=\"checkbox\"> 算法</li>\n</ul>\n<h1 id=\"基础-1\"><a href=\"#基础-1\" class=\"headerlink\" title=\"基础\"></a>基础</h1><h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> TCP</li>\n<li><input disabled=\"\" type=\"checkbox\"> UDP</li>\n<li><input disabled=\"\" type=\"checkbox\"> TCP和UDP的区别</li>\n<li><input disabled=\"\" type=\"checkbox\"> TCP的传输连接管理</li>\n<li><input disabled=\"\" type=\"checkbox\"> TCP的流量和拥塞控制</li>\n<li><input disabled=\"\" type=\"checkbox\"> DNS</li>\n<li><input disabled=\"\" type=\"checkbox\"> MDNS</li>\n<li><input disabled=\"\" type=\"checkbox\"> HTTP协议</li>\n<li><input disabled=\"\" type=\"checkbox\"> HTTPS协议</li>\n<li><input disabled=\"\" type=\"checkbox\"> HTTP协议与</li>\n<li><input disabled=\"\" type=\"checkbox\"> Socket连接</li>\n<li><input disabled=\"\" type=\"checkbox\"> WebRTC</li>\n</ul>\n<h2 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 链表</li>\n<li><input disabled=\"\" type=\"checkbox\"> 队列</li>\n<li><input disabled=\"\" type=\"checkbox\"> 栈</li>\n<li><input disabled=\"\" type=\"checkbox\"> 树</li>\n<li><input disabled=\"\" type=\"checkbox\"> 排序算法</li>\n<li><input disabled=\"\" type=\"checkbox\"> 搜索算法</li>\n<li><input disabled=\"\" type=\"checkbox\"> 深度优先</li>\n<li><input disabled=\"\" type=\"checkbox\"> 广度优先</li>\n<li><input disabled=\"\" type=\"checkbox\"> 动态规划</li>\n<li><input disabled=\"\" type=\"checkbox\"> 贪心算法</li>\n<li><input disabled=\"\" type=\"checkbox\"> 回溯算法</li>\n<li><input disabled=\"\" type=\"checkbox\"> 分治算法</li>\n</ul>\n<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 观察者模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 装饰器模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 工厂模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 单例模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 命令模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 适配器与外观模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 模版方法模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 迭代器和组合模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 状态模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 代理模式</li>\n<li><input disabled=\"\" type=\"checkbox\"> 复合模式</li>\n</ul>\n<h2 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 常见指令</li>\n<li><input disabled=\"\" type=\"checkbox\"> 分支管理</li>\n<li><input disabled=\"\" type=\"checkbox\"> github action</li>\n</ul>\n<h1 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h1><p><strong>参考书籍与博客:</strong></p>\n<ul>\n<li>《你不知道的JavaScript》</li>\n<li><a href=\"https://juejin.cn/post/6940945178899251230?searchId=202311132204230AA4361F743361752A38\">高频前端面试题汇总</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog\">冴羽的博客</a></li>\n<li><a href=\"https://juejin.cn/post/6844903975930576903?from=search-suggest\">iOS学习栈</a></li>\n<li><a href=\"https://juejin.cn/post/6844903829796814861?searchId=20231208175256AC468E4F17F5B1AE6390\">五万字长文 C C++ 面试知识总结（上）</a></li>\n<li><a href=\"https://juejin.cn/post/6900698814093459463?searchId=202312081742232FAED81543052C9BA107#heading-10\">「算法与数据结构」你可能需要的一份前端算法总结</a></li>\n<li>《Head First设计模式》</li>\n</ul>\n","categories":["其他"],"tags":["计划"]},{"title":"MDNS协议与iOS Bonjour","url":"/2023/12/22/Network/MDNS%E5%8D%8F%E8%AE%AE%E4%B8%8EiOS%20Bonjour/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"iOS-Bonjour与MDNS协议\"><a href=\"#iOS-Bonjour与MDNS协议\" class=\"headerlink\" title=\"iOS Bonjour与MDNS协议\"></a>iOS Bonjour与MDNS协议</h1><p><strong>背景</strong></p>\n<p>在VibeOne的早期版本中，是通过后端接口获得跟手机同一网络下的白板设备的。而后端判断手机和设备是否在同一网络的逻辑也相对比较简单，只是通过::判断手机和白板的IP地址是否相同::来判断两者是否处于同一网络。这种判断方式在相对简单的网络环境下，有一定的效果。但是对于复杂的，::多IP出口的网络::，哪怕手机跟白板都连接在同一WI-FI下，也无法正确判断。这个时候，我们就需::要采用局域网服务（设备）发现技术，在iOS端VibeOne采用了Bonjour协议，其中最核心的就是Multicast DNS（多播DNS）协议。::</p>\n<h1 id=\"DNS协议\"><a href=\"#DNS协议\" class=\"headerlink\" title=\"DNS协议\"></a>DNS协议</h1><blockquote>\n<p>既然MDNS是多播DNS协议，那么首先我们需要大致了解一下，什么是DNS协议</p>\n</blockquote>\n<p>::DNS 的全称是 <code>Domain Name System,DNS</code>:: ，是一个由分层的 <code>DNS 服务器（DNS server）</code>实现的分布式数据库，还是一个使得::主机能够查询分布式数据库的应用层协议。::最主要的作用，就是将我们平时访问网站的网址，例如<code>www.baidu.com</code> ，解析成路由器使用的IP地址，例如<code>121.17.106.8</code> 。</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/Network/DNS%E8%A7%A3%E6%9E%90.jpg\" alt=\"Image.tiff\"><br>当我们在浏览器中输入<code>www.xxxx.com/xxxxx.html</code> 这个地址时，为了我们的主机能正确的将HTTP请求报文发送到对应的服务器主机，会经历以下的操作：</p>\n<ul>\n<li>主机上运行着DNS应用的客户端</li>\n<li>浏览器解析地址，获得主机名<code>www.xxxx.com</code> ，并将主机名传递给DNS应用</li>\n<li>DNS应用向DNS服务器发送包含主机名的查询请求</li>\n<li>DNS服务查询后，返回包含主机名对应IP地址的回答报文</li>\n<li>DNS应用客户端获得IP地址后，提供给浏览器，浏览器向位于该 IP 地址 80 端口的 HTTP 服务器进程发起一个 TCP 连接</li>\n</ul>\n<p>这就是DNS协议的基本作用和工作原理，详细的DNS协议内容可以阅读这篇文章<a href=\"https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247503366&idx=4&sn=288f0b3b137ef21712787c8b5ed29c29&chksm=fbb147f8ccc6ceee8d85f824cd2ae9102dd13649dd2861a79537cac293004d1defc394d242d9&scene=27\">万字长文爆肝 DNS 协议</a></p>\n<h1 id=\"单播、广播、多播（组播）\"><a href=\"#单播、广播、多播（组播）\" class=\"headerlink\" title=\"单播、广播、多播（组播）\"></a>单播、广播、多播（组播）</h1><blockquote>\n<p>既然MDNS是多播DNS协议，那么什么是多播呢</p>\n</blockquote>\n<p>::单播、广播和多播（又称组播）是基本的计算机网络概念，表示在网络中报文的不同发送形式。::</p>\n<h2 id=\"单播\"><a href=\"#单播\" class=\"headerlink\" title=\"单播\"></a>单播</h2><p>当主机A中的某个程序想要将一段报文数据发送给计算机网络中的主机B的某个程序（及两个程序进行::目标明确且唯一的数据传输::）时，就可以采用单播的形式。通常的网络协议采用的就是单播的形式，例如TCP协议，需要建立点多点的连接。</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/Network/%E5%8D%95%E6%92%AD.jpg\" alt=\"Image.tiff\"></p>\n<p>但是单播有个前提，就是主机A必::须明确的知道主机B的IP地址和主机B上某个程序所运行的端口::</p>\n<h2 id=\"广播\"><a href=\"#广播\" class=\"headerlink\" title=\"广播\"></a>广播</h2><p>如果主机A不知道主机B的IP地址，那么它还能用什么方式来找到主机B，答案就是采取广播的形式。</p>\n<p>如果主机A中的某个程序采用广播的形式，那么::报文信息将被发送到整个网络中的所有设备。::</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/Network/%E5%B9%BF%E6%92%AD%E5%8F%91%E9%80%81.jpg\" alt=\"Image.tiff\"></p>\n<p>如果主机A在报文信息中携带了自己的IP地址和端口，那么主机B可以采用单播的形式应答主机A</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/Network/%E5%B9%BF%E6%92%AD%E5%BA%94%E7%AD%94.jpg\" alt=\"Image.tiff\"></p>\n<p>如果没有，那么主机B也只能通过广播的形式应答主机A</p>\n<h2 id=\"组播\"><a href=\"#组播\" class=\"headerlink\" title=\"组播\"></a>组播</h2><p>从单播和组播的局限性来看，单播必须明确知道通信方的IP地址，而广播会导致不想收到信息的网络中设备（主机C）也收到报文信息。因此还有另外一种方式，就是组播。</p>\n<p>组播的形式就是将不同的主机::按照服务类型分组::，当请求报文到达组播路由器后，路由器就可以根据服务类型，发送到对应组内的主机。那么一台主机如何加入某个组中呢？</p>\n<p><strong>主机主动加入组：</strong></p>\n<p>主机主动告知网络中的组播路由器要加入某个组，这个时候组播路由器就知道网络内有224.0.0.251组的成员，会建立组的转发表</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/Network/%E7%BB%84%E6%92%AD%E4%B8%BB%E5%8A%A8%E5%8A%A0%E5%85%A5%E7%BB%84.jpg\" alt=\"Image.tiff\"></p>\n<p>当有其他主机发送广播的目的地址为224.0.0.251时，组播路由器会将这个数据包转发给组内的其他成员，所以源主机根本不关注目的主机是谁。</p>\n<p><strong>组播路由器发现组：</strong></p>\n<p>组播路由器会周期的向局域网发送广播查询有哪些组存在</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/Network/%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1%E5%99%A8%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD.jpg\" alt=\"Image.tiff\"></p>\n<p>当组形成以后，主机就可以向组播路由器发送组播信息，组播信息就会被发送到组内所有主机</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/Network/%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1%E5%99%A8%E5%8F%91%E9%80%81%E7%BB%84%E6%92%AD%E4%BF%A1%E6%81%AF.jpg\" alt=\"Image.tiff\"></p>\n<h1 id=\"Bonjour\"><a href=\"#Bonjour\" class=\"headerlink\" title=\"Bonjour\"></a>Bonjour</h1><p>Bonjour协议是由三种协议实现的::Link-Local Address协议、Multicast Dns协议和DNS-SD（dns-base service discovery）协议。::</p>\n<p>Bonjour将底层的具体实现屏蔽，提供给上层应用简单的API，使用者从三种基础通信变成了简单的函数调用：</p>\n<ul>\n<li>通告服务API：用来宣告自己提供哪些服务</li>\n<li>发现服务API：用来查询局域网内是否有它所需要的服务</li>\n<li>解析服务API：通过发现服务API获取服务实例，进一步解析服务提供的信息</li>\n</ul>\n<h2 id=\"Link-Local-Address协议\"><a href=\"#Link-Local-Address协议\" class=\"headerlink\" title=\"Link-Local Address协议\"></a>Link-Local Address协议</h2><p>我们知道，可用于网络通信的设备（计算机、智能手机、路由器等）都有唯一的MAC地址。但是在IP网络中，设备通常使用IP地址进行通信。所以需要将MAC地址和IP私有地址进行绑定。</p>\n<blockquote>\n<p>IPv4的私有地址范围指的是在局域网内部使用的地址，用于在私有网络中提供内部通信功能，不在公网上使用。</p>\n</blockquote>\n<p>::Link-Local Address协议就是将设备的MAC地址和IP私有地址进行绑定::。整个基本流程如下。</p>\n<ol>\n<li>主机选择一个私有地址，使用ARP协议查询选中IP对应的MAC地址，查询三次</li>\n</ol>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/Network/%E6%9F%A5%E8%AF%A2Mac%E5%9C%B0%E5%9D%80%E5%8D%A0%E7%94%A8.jpg\" alt=\"Image.tiff\"></p>\n<ol start=\"2\">\n<li>如果没有查到，则发送组播，宣告自己使用这个IP，同时把自己的MAC地址带上</li>\n</ol>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/%E5%AE%A3%E7%A7%B0%E4%BD%BF%E7%94%A8Mac%E5%9C%B0%E5%9D%80.jpg\" alt=\"Image.tiff\"></p>\n<ol start=\"3\">\n<li>假设查到并得到使用这个IP地址的设备的单播回复，则重新选择IP，并重复流程。</li>\n</ol>\n<p>这样的IP分配算法效率相对低下，但是在局域网内是够用的。</p>\n<h2 id=\"Multicast-DNS\"><a href=\"#Multicast-DNS\" class=\"headerlink\" title=\"Multicast DNS\"></a>Multicast DNS</h2><p>该协议用于在局域网内建立不依赖DNS服务器的解析服务，将设备的IP地址和设备提供的服务的服务名建立联系。</p>\n<p>MDNS的顶级域名是<code>.local</code> ，具体流程如下：</p>\n<ol>\n<li>提供服务的主机将自己提供服务的域名<code>xxx.local</code> 与IP等信息通过组播发送出去查询，发送的是查询报文，重复3次。过程如下：</li>\n</ol>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/Network/%E6%9F%A5%E8%AF%A2MDNS%E5%9C%B0%E5%9D%80%E5%8D%A0%E7%94%A8.jpg\" alt=\"Image.tiff\"></p>\n<p>Multicast DNS的组播地址为224.0.0.251，端口5353</p>\n<ol start=\"2\">\n<li>如果没有其他主机回复，则会再发一次组播，宣告自己提供服务，IP是XXXX，端口是XXXX，发送的是响应报文，其他机器收到后会更新本地的DNS缓存。</li>\n</ol>\n<p>![Image.tiff](img&#x2F;Network&#x2F;宣称提供MDNS服务.jpg</p>\n<ol start=\"3\">\n<li>如果有人回复该域名已经有映射关系，服务主机会更新域名，并重复。</li>\n</ol>\n<h2 id=\"DNS-SD-dns-based-serveice-discovery-协议\"><a href=\"#DNS-SD-dns-based-serveice-discovery-协议\" class=\"headerlink\" title=\"DNS-SD (dns-based serveice discovery)协议\"></a>DNS-SD (dns-based serveice discovery)协议</h2><p>DNS- SD协议使用MDNS的资源记录功能中的三种类型存储去建立服务类型、服务实例、服务实例IP+PORT的映射关系，以达到快速发现服务的目的。</p>\n<blockquote>\n<p>MDNS 为什么不直接实现服务发现功能？</p>\n</blockquote>\n<blockquote>\n<p>MDNS的功能定义是明确的，用于实现无DNS服务的域名解析。服务发现不属于它该有的功能，这种功能属于具体业务场景。所以Bonjour通过DNS- SD与MDNS结合起来，实现服务发现。</p>\n</blockquote>\n<p>简而言之：该协议定义了三种存储类型的数据格式，相当于建立通讯录，以及通讯录里面的数据格式，以便于发现服务。</p>\n<p>DNS- SD对MDNS数据段的使用方式如下：</p>\n<ul>\n<li>PTR记录：将服务名称与服务类型建立映射关系</li>\n<li>SRV记录：将服务于IP地址和端口号建立映射关系</li>\n<li>TXT记录：服务所附带的其他数据</li>\n</ul>\n<p>下面就是DNS- SD的工作过程：</p>\n<p><strong>查询及宣告服务：</strong></p>\n<ol>\n<li><p>查询服务</p>\n<p>发送的是查询报文，查询三次，DNS- SD基于MDNS将服务域名于IP和PORT的信息放在SRV区域：</p>\n</li>\n</ol>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/Network/DNS-SD%E6%9F%A5%E8%AF%A2%E6%9C%8D%E5%8A%A1.jpg\" alt=\"Image.tiff\"></p>\n<ol>\n<li><p>宣告服务</p>\n<p>如果没有其他主机回复则会再次使用组播，宣告自己提供服务，发送的是PTR响应报文：</p>\n</li>\n</ol>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/Network/DNS-SD%E5%AE%A3%E5%91%8A%E6%9C%8D%E5%8A%A1.jpg\" alt=\"Image.tiff\"></p>\n<ol>\n<li><p>服务冲突</p>\n<p>如果有收到回复存在冲突，将服务域名更改并重复第1、2步</p>\n</li>\n</ol>\n<p><strong>发现服务：</strong></p>\n<p>主机定期通过组播查询某个类型的服务列表，发送的是PTR查询报文，因为一开始查的都是某个服务类型，进而获得某个服务类型的服务列表</p>\n<p><strong>解析服务：</strong></p>\n<p>发现服务发送的是PTR查询，IP和服务域名的映射关系存放在SRV数据段中，所以想获得具体IP需要进一步对服务进行解析</p>\n<p>在MAC中，可以是使用dns-sd命令进行查询，例如，我们使用<code>dns-sd -Z _vibecast._tcp</code> 命令查询当前网络中所有提供<code>_vibecast._tcp</code> 服务的信息</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"https://res.craft.do/user/full/04f0041a-9b0f-c3ea-84a7-d85225a7805c/doc/3853E871-3CB5-439F-9D53-2A9AC7E63E7C/18C39D9B-82EA-427A-83BA-38E3EBF54A76_2/cm4btAE0h9eOCYNppZAwjT7l8arf2rgiYd4ieGj04Jwz/Image.png\" alt=\"Image.png\"></p>\n<p>其中SRV信息需要通过<code>dns-sd -q</code> 命令进一步解析</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"https://res.craft.do/user/full/04f0041a-9b0f-c3ea-84a7-d85225a7805c/doc/3853E871-3CB5-439F-9D53-2A9AC7E63E7C/2A769DD1-EB7D-445A-A3C0-B00736D842BE_2/Q9IHSI2hAuEmPWEPxvcUCuxEGws7KI61xL5w95PQd4Ez/Image.png\" alt=\"Image.png\"></p>\n<h2 id=\"具体代码\"><a href=\"#具体代码\" class=\"headerlink\" title=\"具体代码\"></a>具体代码</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)createServiceBrowser &#123;</span><br><span class=\"line\">  [<span class=\"keyword\">self</span>.netDeviceArray removeAllObjects];</span><br><span class=\"line\">  <span class=\"keyword\">self</span>.vibeBrowser = [[<span class=\"built_in\">NSNetServiceBrowser</span> alloc] init];</span><br><span class=\"line\">  <span class=\"keyword\">self</span>.vibeBrowser.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">  [<span class=\"keyword\">self</span>.vibeBrowser scheduleInRunLoop:[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</span><br><span class=\"line\">  [<span class=\"keyword\">self</span>.vibeBrowser searchForServicesOfType:<span class=\"string\">@&quot;_vibecast._tcp&quot;</span> inDomain:<span class=\"string\">@&quot;local.&quot;</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这部分主要就是创建<code>NSNetServiceBrowser</code> 实例，并设置需要查询的服务域名和顶级域名。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)netServiceBrowser:(<span class=\"built_in\">NSNetServiceBrowser</span> *)browser</span><br><span class=\"line\">           didFindService:(<span class=\"built_in\">NSNetService</span> *)service</span><br><span class=\"line\">               moreComing:(<span class=\"type\">BOOL</span>)moreComing &#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;NetServiceBrowser:: Find service: %@&quot;</span>, service);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (NetDevice *nd <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.netDeviceArray) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([nd.service.hostName isEqualToString:service.hostName]) &#123;</span><br><span class=\"line\">      DDLogError(<span class=\"string\">@&quot;The service already exists in the cache! Please check!&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  service.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">  [service startMonitoring];</span><br><span class=\"line\">  [service resolveWithTimeout:<span class=\"number\">15</span>];</span><br><span class=\"line\">  NetDevice *netDevice = [[NetDevice alloc] initWithService:service];</span><br><span class=\"line\">  [<span class=\"keyword\">self</span>.netDeviceArray addObject:netDevice];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)netServiceBrowser:(<span class=\"built_in\">NSNetServiceBrowser</span> *)browser</span><br><span class=\"line\">         didRemoveService:(<span class=\"built_in\">NSNetService</span> *)service</span><br><span class=\"line\">               moreComing:(<span class=\"type\">BOOL</span>)moreComing &#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;NetServiceBrowser:: Remove service: %@&quot;</span>, service);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (NetDevice *nd <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.netDeviceArray) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// delegate will give a new service instance, so just can find the same device by name</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([nd.service.name isEqualToString:service.name]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nd.info[<span class=\"string\">@&quot;deviceUserId&quot;</span>]) &#123;</span><br><span class=\"line\">        [[FindDeviceModule share] deviceRemove:nd.info[<span class=\"string\">@&quot;deviceUserId&quot;</span>]];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      [<span class=\"keyword\">self</span>.netDeviceArray removeObject:nd];</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  DDLogError(<span class=\"string\">@&quot;In general, code never run into here, please check!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这部分通过<code>NSNetServiceBrowser</code> 实例的两个生命周期函数，来记录搜寻到的和移除的服务记录</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)netService:(<span class=\"built_in\">NSNetService</span> *)sender didUpdateTXTRecordData:(<span class=\"built_in\">NSData</span> *)data &#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSDictionary</span> *recordDict = [<span class=\"built_in\">NSNetService</span> dictionaryFromTXTRecordData:data];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (NetDevice *nd <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.netDeviceArray) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nd.service == sender) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *str <span class=\"keyword\">in</span> [recordDict allKeys]) &#123;</span><br><span class=\"line\">        nd.info[str] = [[<span class=\"built_in\">NSString</span> alloc] initWithData:recordDict[str] encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.isExecuted) &#123;</span><br><span class=\"line\">        [[FindDeviceModule share] deviceChange];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  DDLogError(<span class=\"string\">@&quot;In general, code never run into here, please check!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当一台设备的TXTRecord信息改变时，就会更新存储的设备列表里的信息</p>\n","categories":["基础"],"tags":["计算机网络"]},{"title":"Objetive-C - 基于引用计数的内存管理","url":"/2023/12/13/Objective-C/Objetive-C%20-%20%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"动态内存管理\"><a href=\"#动态内存管理\" class=\"headerlink\" title=\"动态内存管理\"></a>动态内存管理</h1><h2 id=\"内存管理的必要性\"><a href=\"#内存管理的必要性\" class=\"headerlink\" title=\"内存管理的必要性\"></a>内存管理的必要性</h2><p>当程序运行结束时，操作系统会释放为期分配的内存。如果是很小、运行时间很短的程序，就算内存没有释放也不会有问题，程序结束以后操作系统就会自动释放内存。但对于长时间运行的程序，如果没能妥善管理内存，导致需要释放的内存没有释放，反而不断分配新的内存，这样程序所占用的内存将持续升高，程序运行速度将越来越慢，甚至会因为内存耗尽而崩溃。<br>我们将程序未能释放的不再使用的内存的行为称为<strong>内存泄漏</strong>，而如果指针所指向的对象已经被释放或收回，该指针就被称为<strong>悬垂指针</strong>或野指针。继续使用这种指针同样会导致内存崩溃。<br>Objective-C会通过向类对象发送alloc消息来生成实例对象，alloc的作用就是分配内存。alloc方法的返回值是id类型,id类型实则就是指针类型，而其所指向的就是为实例对象分配的内存。生成的实例对象用完之后不被释放，就会发生内存泄漏。另一方面，如果给已经释放了的实例对象发消息，就有可能导致程序错误或异常终止。</p>\n<h2 id=\"引用计数、自动引用计数和自动垃圾回收\"><a href=\"#引用计数、自动引用计数和自动垃圾回收\" class=\"headerlink\" title=\"引用计数、自动引用计数和自动垃圾回收\"></a>引用计数、自动引用计数和自动垃圾回收</h2><p>Cocoa环境的Objective-C提供了一种动态的内存管理模式，称为<strong>引用计数</strong>(reference counter)。这种方式会跟踪每个对象被引用的次数，当对象的引用次数为0时，系统就会释放这个对象所占用的内存。<br>比引用计数内存管理更高级一点的就是自动引用计数(Automatic Reference Counting, 简写为ARC)的内存管理。自动引用计数提供了自动评估对象生存期的功能，在编译期间会自动加入合适的内存管理的方法。<br>除了ARC外，Objective-C2.0还引入了另外一种自动内存管理机制——垃圾回收。使用垃圾回收时，就不再需要通过引用计数来管理创建的对象，系统会自动识别哪些对象仍在使用，哪些对象可以回收。</p>\n<table>\n<thead>\n<tr>\n<th>内存管理方式</th>\n<th>难易度</th>\n<th>Mac</th>\n<th>iOS</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>手动引用计数</td>\n<td>较难</td>\n<td>支持｜支持｜默认方式</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>自动引用计数</td>\n<td>容易</td>\n<td>支持</td>\n<td>支持</td>\n<td>建议采用</td>\n</tr>\n<tr>\n<td>垃圾回收</td>\n<td>容易</td>\n<td>支持</td>\n<td>不支持</td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"手动引用计数内存管理\"><a href=\"#手动引用计数内存管理\" class=\"headerlink\" title=\"手动引用计数内存管理\"></a>手动引用计数内存管理</h1><h2 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h2><p>每个对象都有一个与之相关的整数，称作它的引用计数。当某段代码需要使用一个对象时，就将该对象的引用计数器值加1.当这段代码不再使用这个对象时，则将对象的引用计数器值减1.换言之，引用计数就是指程序中到底有多少个地方需要访问这个对象<br>使用alloc和初始化方法创建一个对象时，该对象的引用计数的初始值为1，假设有一个类A在尽心某些操作的过程中需要使用到实例B，为了防止实例B被别的对象随意释放，类A会事先给实例B发送一个retain消息。这样，每执行一次retain，实例B的引用计数就会加1.<br>反之，不再需要某个对象时，可以通过发送release消息，使对象的引用计数减1.<br>实际上，释放内存的并不是release方法，而是dealloc方法。同alloc不同，dealloc不是类方法，而是一个实例方法。当对象的引用计数值为0时，Objective-C会自动向对象发送一条dealloc消息来释放内存。通常并不允许在程序内直接调用dealloc方法。<br>让我们通过一个例子来看看引用计数到底如何工作。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/NSObject.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> main();</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">  printf(<span class=\"string\">&quot;init: %d\\n&quot;</span>, (<span class=\"type\">int</span>)[obj retainCount]);</span><br><span class=\"line\">  [obj <span class=\"keyword\">retain</span>];</span><br><span class=\"line\">  printf(<span class=\"string\">&quot;retain: %d\\n&quot;</span>, (<span class=\"type\">int</span>)[obj retainCount]);</span><br><span class=\"line\">  [obj <span class=\"keyword\">retain</span>];</span><br><span class=\"line\">  printf(<span class=\"string\">&quot;retain: %d\\n&quot;</span>, (<span class=\"type\">int</span>)[obj retainCount]);</span><br><span class=\"line\"></span><br><span class=\"line\">  [obj release];</span><br><span class=\"line\">  printf(<span class=\"string\">&quot;release: %d\\n&quot;</span>, (<span class=\"type\">int</span>)[obj retainCount]);</span><br><span class=\"line\">  [obj release];</span><br><span class=\"line\">  printf(<span class=\"string\">&quot;release: %d\\n&quot;</span>, (<span class=\"type\">int</span>)[obj retainCount]);</span><br><span class=\"line\">  [obj release];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"释放对象的方法\"><a href=\"#释放对象的方法\" class=\"headerlink\" title=\"释放对象的方法\"></a>释放对象的方法</h2><p>在自定义类的时候，如果类的实例变量是一个对象类型，那么，在销毁类的对象的时候，也要给类的实例变量发送release消息。释放一个类的实例对象时，为了彻底释放该实例对象所保持的所有对象的所有权，需要为该重写dealloc方法，在其中释放所有已经分配的资源</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>) dealloc &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里通过release方法放弃子类中所有实例变量的所有权</span></span><br><span class=\"line\">  <span class=\"comment\">// 其他用于释放前的最后操作也写在这里</span></span><br><span class=\"line\">  [<span class=\"variable language_\">super</span> dealloc];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"访问方法和对象所有权\"><a href=\"#访问方法和对象所有权\" class=\"headerlink\" title=\"访问方法和对象所有权\"></a>访问方法和对象所有权</h2><p>在通过访问方法等改变拥有实例变量所有权的对象时，必须注意实例变量引用计数的变化。合理安排release和retain的先后顺序。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setMyValue: (<span class=\"type\">id</span>)obj &#123;</span><br><span class=\"line\">\t[myValue release];</span><br><span class=\"line\">\tmyValue = [obj <span class=\"keyword\">retain</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这么写绝大多数情况下都没有问题，只有一种情况下会有问题，就是当obj和myValue指向同一个对象时，率先release 就会导致对象被释放掉。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setMyValue: (<span class=\"type\">id</span>)obj &#123;</span><br><span class=\"line\">\t[obj <span class=\"keyword\">retain</span>];</span><br><span class=\"line\">\t[myValue release];</span><br><span class=\"line\">\tmyValue = obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自动释放\"><a href=\"#自动释放\" class=\"headerlink\" title=\"自动释放\"></a>自动释放</h2><p>在实际编程的时候，会遇到很多只用一次就不再使用的对象。而这种对象需要逐一释放，那将是一件很麻烦的事情。<br>Cocoa环境的Objective-C提供了一种对象<strong>自动释放</strong>(autorelease)的机制。这种机制的基本思想是把所有需要发送release消息的对象记录下来，等到需要释放这些对象时，会给这些对象一起发送release消息。其中，类NSAutoreleasePool（自动释放池）就起到了记录的作用。<br>首先我们生成了一个NSAutoreleasePool的实例对象。当像一个对象发送autorelease消息时，实际上就会将该对象添加到NSAutoreleasePool中，将它标记为以后释放。这个时候，因为这个对象没有被释放，所以还可以继续使用。但是当自动释放池被销毁时，池中记录的所有对象都会被发送release消息。这种在自动释放池里记录的对象也被称为临时对象</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSAutoreleasePool</span> *pool = [[<span class=\"built_in\">NSAutoreleasePool</span> alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个对象并发送 autorelease 消息</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *autoReleasedString = [[<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@&quot;Hello, World!&quot;</span>] autorelease];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在这里可以继续使用 autoReleasedString</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当池被销毁时，autoReleasedString 会自动接收到 release 消息</span></span><br><span class=\"line\">[pool release];</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，在ARC环境下，需要使用<code>drain</code>消息来销毁自动释放池</p>\n<h2 id=\"临时对象的生成\"><a href=\"#临时对象的生成\" class=\"headerlink\" title=\"临时对象的生成\"></a>临时对象的生成</h2><p>除了这种标准的创建对象的方法外，还有一种创建临时对象的方法。通过这种方法创建的对象都是临时对象，生成之后会被直接加入到内部的自动释放池，你不需要关心如何销毁它<br>例如，Cocoa里用于处理字符串的类NSString，由UTF-8编码的C风格字符串生成NSString对象的方法有两个</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">id</span>) initWithUTF8String: (<span class=\"keyword\">const</span> <span class=\"type\">char</span> *) bytes</span><br><span class=\"line\"><span class=\"comment\">// alloc生成的实例对象的初始化方法，生成的实例对象的初始化引用计数为1</span></span><br><span class=\"line\">+ (<span class=\"type\">id</span>) stringWithUTF8String: (<span class=\"keyword\">const</span> <span class=\"type\">char</span> *) bytes</span><br><span class=\"line\"><span class=\"comment\">// 生成临时变量的类方法，生成的实例对象会被自动加入到自动释放池中</span></span><br></pre></td></tr></table></figure>\n<p>Objective-C中的很多类都提供这种生成临时对象的类方法。这种类方法的命名规则是，不以init开头，而以要生成的对象类型作为开头。<br>这种生成临时对象的类方法，在Objective-C中称为<strong>便利构造函数</strong>或<strong>便利构造器</strong></p>\n<h2 id=\"常量对象\"><a href=\"#常量对象\" class=\"headerlink\" title=\"常量对象\"></a>常量对象</h2><p>内存中常量对象（类对象，常量字符串对象等）的空间分配与其他对象不同，他们没有引用计数机制，永远不能释放这些对象。给这些对象发送retainCount后，返回的是NSUIntegerMax（最大的无符号数）<br>常量对象的生成和释放操作和一般对象有所不同，有时需要重写retain和release方法的实现。但考虑到ARC和垃圾回收中无法重写这些方法，因此，从兼容性的角度来看，不建议重写retain和release方法。</p>\n","categories":["iOS"],"tags":["Objective-C"]},{"title":"JavaScript - 作用域和闭包","url":"/2023/12/10/JavaScript/JavaScript%20-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"什么是作用域\"><a href=\"#什么是作用域\" class=\"headerlink\" title=\"什么是作用域\"></a>什么是作用域</h1><h2 id=\"理解作用域\"><a href=\"#理解作用域\" class=\"headerlink\" title=\"理解作用域\"></a>理解作用域</h2><p>JavaScript实际上是一门编译语言。在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为编译：</p>\n<ul>\n<li>分词&#x2F;词法分析：<br>  将字符串分解成有意义的代码块，称为词法单元</li>\n<li>解析&#x2F;语法分析：<br>  将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，称为抽象语法树（AST）</li>\n<li>代码生成：<br>  将AST转换成可执行代码</li>\n</ul>\n<p>想要理解作用域，首先我们需要理解在一个变量定义的过程中，例如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>到底做了些什么。<br>这看起来像是完整的一句声明，但是在JS引擎看来，这是两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎处理。</p>\n<p>编译器首先会进行以下处理：</p>\n<ol>\n<li>遇到 <code>var a</code>，询问作用域内是否已经有一个该名称的变量存在于同一个作用域的集合中。如果有，则忽略该声明，进行后续编译。否则会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a</li>\n<li>编译器为引擎生成运行时所需要的代码，用于处理 <code>a = 2</code>这个赋值语句。引擎运行时，会询问作用域，当前作用域集合中是否存在一个叫做a的变量。如果时，则使用这个变量；否，引擎将继续向上层集合中查找这个变量</li>\n</ol>\n<p>引擎对于变量a进行的查找称为LHS查询，另外一个查找类型叫做RHS。</p>\n<h2 id=\"作用域嵌套\"><a href=\"#作用域嵌套\" class=\"headerlink\" title=\"作用域嵌套\"></a>作用域嵌套</h2><p>当一个块和函数嵌套在另一个块或函数中时，就会发生作用域嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，知道找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</p>\n<h1 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h1><p>作用域共有两种主要的工作模式。第一种是最为普遍的，被大多数编程语言所采用的词法作用域。另一种则相对小众，叫做动态作用域。</p>\n<h2 id=\"词法阶段\"><a href=\"#词法阶段\" class=\"headerlink\" title=\"词法阶段\"></a>词法阶段</h2><p>大部分标准语言编译器的第一个阶段叫做词法化，词法化的概念是理解词法作用域及其名称来历的基础。<br>简单得说，词法作用域就是定义在词法阶段的作用域，由写代码时将变量和块作用域写在哪里来决定。</p>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><p>作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫做“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）</p>\n<p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定</p>\n<p>词法作用域查找只会查找一级标识符。如果代码中引用了<code>foo.bar.baz</code>，那么词法作用域支付则查找到foo标识符。找到这个变量后，对象属性访问规则会分别接管对bar和baz的访问。</p>\n<h1 id=\"函数作用域和块作用域\"><a href=\"#函数作用域和块作用域\" class=\"headerlink\" title=\"函数作用域和块作用域\"></a>函数作用域和块作用域</h1><h2 id=\"函数中的作用域\"><a href=\"#函数中的作用域\" class=\"headerlink\" title=\"函数中的作用域\"></a>函数中的作用域</h2><p>每声明一个函数，都会创建一个函数作用域。函数作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用及服用。<br>因此我们可以通过在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何东西。但是这种方式同样会创造一个函数名，对命名空间造成“无法”。为此，JS有两种解决方案<br><strong>匿名函数表达式：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;aaa&#x27;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>立即执行函数表达式：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"keyword\">function</span> <span class=\"title function_\">IIFE</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span>  a = <span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h2><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 块作用域</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>块作用域的作用就是将变量的声明尽可能的靠近使用的地方，并最大限度地本地化。<br>块作用域需要使用<code>let</code>关键字定义，<code>var</code>声明的变量，最终都会是属于外部作用域的。此外还可以使用const来定义块作用域变量，它定义的变量是常量变量。</p>\n<h1 id=\"声明提升\"><a href=\"#声明提升\" class=\"headerlink\" title=\"声明提升\"></a>声明提升</h1><p>使用var声明变量，会导致声明提示，而let和const则不会。<br>因为对于编译器来说，变量的声明会在编译阶段进行，而赋值声明则会被留在引擎执行阶段执行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其实对于编译器来说</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a; <span class=\"comment\">// 声明提升</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>函数优先</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">foo</span>(); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>这样的执行结果是因为函数声明和变量声明都会提升，且函数声明会首先提升</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo; <span class=\"comment\">// foo已经声明，这段声明会被忽略</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">foo = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"作用域闭包\"><a href=\"#作用域闭包\" class=\"headerlink\" title=\"作用域闭包\"></a>作用域闭包</h1><p>当函数可以记住并访问在的词法作用域时,就产生了闭包，即使函数是在当前词法作用域外执行的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">bar</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = <span class=\"title function_\">foo</span>();</span><br><span class=\"line\"><span class=\"title function_\">baz</span>(); <span class=\"comment\">// 2 闭包的效果</span></span><br></pre></td></tr></table></figure>\n<p>函数bar的词法作用域能够访问foo内部的作用域。然后我们调用foo函数，将函数bar传出。这个时候foo虽然已经执行完成，但foo内部的作用域不会被销毁，因为baz所指向的bar函数仍保持对这块作用域的使用。需要等所有指向bar函数的变量被释放，bar函数被回收，foo的作用域才能得到释放。</p>\n<p>无论通过任何手段将能访问外部作用的函数传递到所在的词法作用域外，它都会保持对原始定义作用域的引用（及形成闭包），无论在任何处执行这个函数都会使用闭包</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">wait</span>(<span class=\"params\">message</span>) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message);</span><br><span class=\"line\">\t&#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">wait</span>(<span class=\"string\">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>这里也有一个闭包，在wait函数执行1000毫秒后，它的内部作用域并不会消失，timer函数依然保有wait作用域的闭包。实际上，只要使用了回调函数，就是在使用闭包。</p>\n<p>闭包一个最经典的例子就是处理下面这种循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">\t&#125;, i*<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这只会输出五次六。因为在这个例子里，i和五个回调函数都在一个共享的全局作用域里，五个函数使用的是同一个i。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\t(<span class=\"keyword\">function</span>(<span class=\"params\">j</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(j);</span><br><span class=\"line\">\t\t&#125;, j*<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t&#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就形成了5个闭包，每个闭包内包裹着传入的当时的i，这也是为什么要将i以参数的形式穿进去。否则，虽然形成了5个闭包，但是闭包内是空的，导致最后执行的时候，查询到的值还是在全局作用域中的那个唯一的i。</p>\n<p>不过有了let 以后，就不再需要这么复杂的写法了。let会在块作用域中声明变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">\t&#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h1><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">CoolModule</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> something = <span class=\"string\">&#x27;cool&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> another = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(something);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">doAnother</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(another.<span class=\"title function_\">jon</span>(<span class=\"string\">&#x27;-&#x27;</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tdoSomething,</span><br><span class=\"line\">\t\tdoAnother,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"title class_\">CoolModule</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doSomething</span>();</span><br></pre></td></tr></table></figure>\n<p>这种方式在JS中被称为模块。看起来好像并没有闭包的存在。但是，实际上返回的对象持有内部函数，而内部函数又访问了函数内部变量。所以闭包已经形成了。<br>模块模式需要具备两个必要条件：</p>\n<ol>\n<li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）</li>\n<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态</li>\n</ol>\n<p>在ES6中，文件会被当作独立的模块处理。每个模块都可以导入其他模块或特定的API成员，也可以导出自己的API成员。</p>\n","categories":["前端"],"tags":["JavaScript"]},{"title":"Objecitve-C - 对象的类型和动态绑定","url":"/2023/12/06/Objective-C/Objecitve-C%20-%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"动态绑定\"><a href=\"#动态绑定\" class=\"headerlink\" title=\"动态绑定\"></a>动态绑定</h1><h2 id=\"什么是动态绑定\"><a href=\"#什么是动态绑定\" class=\"headerlink\" title=\"什么是动态绑定\"></a>什么是动态绑定</h2><p>实际的程序会使用各种各样的类的实例对象，所有这些对象都可以用id类型来表示，因为id是通用的对象类型，可以用来存储任何类的对象。但这样一来，程序中就会出现无法区分某个实例对象到底是哪个类的对象的情况。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/NSObject.h&gt;</span><br><span class=\"line\">#import &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface A : NSObject</span><br><span class=\"line\">- (void)whoAreYou;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation A</span><br><span class=\"line\">- (void)whoAreYou &#123; printf(&quot;I&#x27;m A\\n&quot;); &#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@interface B : NSObject</span><br><span class=\"line\">- (void)whoAreYou;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation B</span><br><span class=\"line\">- (void)whoAreYou &#123; printf(&quot;I&#x27;n B\\n&quot;); &#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void) &#123;</span><br><span class=\"line\">\tid obj;</span><br><span class=\"line\">\tint n;</span><br><span class=\"line\"></span><br><span class=\"line\">\tscanf(&quot;%d&quot;, &amp;n);</span><br><span class=\"line\">\tswitch (n) &#123;</span><br><span class=\"line\">\t\tcase 0: obj = [[A alloc] init]; break;</span><br><span class=\"line\">\t\tcase 1: obj = [[B alloc] init]; break;</span><br><span class=\"line\">\t\tcase 2: obj = [[NSObject alloc] init]; break;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t[obj whoAreYou];</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该程序会根据从终端读入的数字的不同，让obj指向不同的类的对象。类A和B中都实现了<code>whoAreYou</code>方法，NSObject中没实现这个方法。但编译时不会给出任何警告信息，会正常生成可执行文件。但是执行程序时一旦输入2，则会获得以下异常</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Terminating app due to uncaught exception &#x27;NSInvalidArgumentException&#x27;, reason: &#x27;- [NSObject whoAreYou]: unrecognized selector sent to instance 0x103f00&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>出错的原因在于类NSObject的实例对象中没有实现<code>whoAreYou</code>方法，所以出现运行时错误。而编译时之所以没出错，是因为编译时无法确定存储在id中的对象的类型。<br>Objective-C中的消息是在运行时才去绑定的。运行时系统首先会确定接收者的类型（动态类型识别），然后根据消息名在类的方法列表里选择相应的方法执行，如果没有找到就到父类中继续寻找，假如一直找到NSObject也没有找到要调用的方法，就会报告上述不能识别消息的错误。<br><strong>动态绑定</strong>（dynamic binding) 指的就是在程序执行时才确定对象的属性和需要响应的消息。</p>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>在面向对象的程序设计理论中，<strong>多态(polymor phism)</strong> 是指，同一操作作用于不同的类的实例时，将产生不同的执行结果。即不同类的对象收到相同的消息时，也能得到不同的结果。<br>我们通过一个绘制图形的例子来理解多态的特性。在面向过程的程序设计中，应该如此编写：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(target-&gt;kind) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Line:</span><br><span class=\"line\">\t\tlineDragged(direction);</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Circle:</span><br><span class=\"line\">\t\tcircleMove(direction);</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> Rectangle:</span><br><span class=\"line\">\t\tRectangleMove(direction);</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而使用多态的情况下，只要将各个图形都定义成一个类，其中实现自己的direction方法，并根据target实际指向的对象的不同，来调用不同的direction操作</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">[target move:direction];</span><br></pre></td></tr></table></figure>\n<p>多态的另外一个优点就是：利用继承可以更容易的定义新的类</p>\n<h1 id=\"作为类型的类\"><a href=\"#作为类型的类\" class=\"headerlink\" title=\"作为类型的类\"></a>作为类型的类</h1><h2 id=\"把类作为一种类型\"><a href=\"#把类作为一种类型\" class=\"headerlink\" title=\"把类作为一种类型\"></a>把类作为一种类型</h2><p>我们可以把定义好的类作为对象的类型，也可以作为变量的类型，方法或函数的参数和返回值类型。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">Volume *v1, *v2;</span><br><span class=\"line\">v1 = [[Volume alloc] initWithMin: <span class=\"number\">0</span> max: <span class=\"number\">10</span> step1: <span class=\"number\">1</span>];</span><br><span class=\"line\">v2 = v1;</span><br><span class=\"line\">[v1 up];</span><br><span class=\"line\">printf(<span class=\"string\">&quot;%d\\n&quot;</span>, [v2 value]);</span><br></pre></td></tr></table></figure>\n<p>其中v2指向v1所指的对象。所以输出的是改变后的值。同样，当消息的参数是对象时，实际上传递的是指向这个对象的指针而不是对象本身，根据消息处理中操作的不同，有可能会更改对象的值。</p>\n<h2 id=\"空指针nil\"><a href=\"#空指针nil\" class=\"headerlink\" title=\"空指针nil\"></a>空指针nil</h2><p>Objective-C中，nil表示一个空的对象，这个对象的指针指向空。nil是指向id类型的指针，值为0 。初始化方法失败的时候通常会返回nil。<br>新生成一个实例变量的时候，alloc方法会把数值类型的实例变量初始化为0，id和其他类型的指针变量也会被初始化为nil<br>返回值为id类型的方法中，如果处理出错的话一般也会返回nil。调用端会采用如下语句来判断方法调用是否成功</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ([list entryForKey: <span class=\"string\">&quot;NeXT&quot;</span>])</span><br></pre></td></tr></table></figure>\n<h2 id=\"静态类型检查\"><a href=\"#静态类型检查\" class=\"headerlink\" title=\"静态类型检查\"></a>静态类型检查</h2><p>虽然在Objective-C中id数据类型可以用来存储任何类型的对象，但绝大多数情况下我们还是将一个变量声明为特定类的对象，这种情况称为静态类型。使用静态类型时，编译器在编译时可以进行类型检查，如果类型不符合会提示警告。<br>我们可以通过下面的这个例子来看看Objective-C的类型检查。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/NSObject.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">A</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)whoAreYou;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">A</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)whoAreYou &#123; printf(<span class=\"string\">&quot;I&#x27;m A\\n&quot;</span>); &#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">B</span> : <span class=\"title\">A</span></span></span><br><span class=\"line\"> - (<span class=\"type\">void</span>)whoAreYou;</span><br><span class=\"line\"> - (<span class=\"type\">void</span>)sayHello;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">B</span></span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)whoAreYou &#123; printf(<span class=\"string\">&quot;I&#x27;m B\\n&quot;</span>); &#125; <span class=\"comment\">/* override */</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)sayHello &#123; printf(<span class=\"string\">&quot;Hello\\n&quot;</span>); &#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">C</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">- (<span class=\"type\">void</span>) printName;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">C</span></span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)printName &#123; printf(<span class=\"string\">&quot;I&#x27;m C\\n&quot;</span>); &#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> main(<span class=\"type\">void</span>) &#123;</span><br><span class=\"line\">\tA *a, *b;</span><br><span class=\"line\">\tC *c;</span><br><span class=\"line\">\ta = [[A alloc] init];</span><br><span class=\"line\">\tb = [[B alloc] init];</span><br><span class=\"line\">\tc = [[C alloc] init];</span><br><span class=\"line\">\t[a whoAreYou];</span><br><span class=\"line\">\t[b whoAreYou];</span><br><span class=\"line\">\t[c whoAreYou];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类A和类是C是相互独立的两个类，类B是类A的子类。main函数中所有的变量都采用静态类型定义<br>编写这段程序会有如下警告。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">warning: <span class=\"string\">&#x27;C&#x27;</span> may not respond to <span class=\"string\">&#x27;whoAreYou&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>虽然变量a和b都被声明为类A类型的变量，但编译器并没有提示警告。原因在于，如果仅仅使用父类中定义的功能，则变量的类型声明为父类也是没有问题的。<br>如果我们修改b调用的方法为</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">[b sayHello];</span><br></pre></td></tr></table></figure>\n<p>则会提示报错，因为我们将b定义为类型A。不过程序可以执行，因为b确实有sayHello方法。<br>我们可以使用强制类型转换，不让编译起报错</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">[(B *)b sayHello];</span><br></pre></td></tr></table></figure>\n<p>但是</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">[(B *)a whoAreYou];</span><br></pre></td></tr></table></figure>\n<p>实际输出还是<code>I&#39;m A</code>，也就是说强制类型转换无效，实际执行的方法是由对象的类型决定的。</p>\n<h2 id=\"静态类型检查的总结\"><a href=\"#静态类型检查的总结\" class=\"headerlink\" title=\"静态类型检查的总结\"></a>静态类型检查的总结</h2><ol>\n<li>对于id类型的变量，调用任何方法都能够通过编译（当然调用不恰当的方法会出现运行时错误）</li>\n<li>id类型的变量和被定义为特定类的变量之间是可以相互赋值的</li>\n<li>被定义为特定类对象的变量（静态类型），如果调用类或父类中未定义的方法，编译器就会提示警告</li>\n<li>如果是静态类型的变量，子类类型的实例变量可以赋值给父类类型的实例变量</li>\n<li>若是静态类型的变量，父类类型的实例变量不可以赋值给子类类型的实例变量</li>\n<li>若是要判断到底是哪个类的方法被执行，不要看变量声明的类型，而是要看实际执行时这个变量的类型</li>\n<li>id类型并不是<code>NSObject *</code>类型<br>Objective-C的静态类型检查是在编译期间完成的。向一个静态类型的对象发送消息时，编译器可以确保接收者可以响应该消息，否则会发出警告；当把一个静态类型的对象赋值给一个静态类型的变量时，编译器可以确保这种赋值是兼容的，否则会发出警告。运行时实际被执行的方法同变量定义是的类型无关。</li>\n</ol>\n<h1 id=\"编程中的类型定义\"><a href=\"#编程中的类型定义\" class=\"headerlink\" title=\"编程中的类型定义\"></a>编程中的类型定义</h1><h2 id=\"签名不一致时的情况\"><a href=\"#签名不一致时的情况\" class=\"headerlink\" title=\"签名不一致时的情况\"></a>签名不一致时的情况</h2><p><strong>消息选择器</strong>中并不包含参数和返回值的类型的信息，消息选择器和这些类型信息结合起来构成<strong>签名</strong>( signature)，签名被用于在运行时标记一个方法。接口文件中方法的定义也叫做签名</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">id</span>)cellAtRow: (<span class=\"type\">int</span>)row column: (<span class=\"type\">int</span>)col;</span><br></pre></td></tr></table></figure>\n<p>Cocoa提供了类<code>NSMethodSignature</code>，以面向对象的方式来记录方法的参数个数、参数类型和返回值类型等信息。这个类的实例也叫做方法签名。<br>Objective-C中选择器相同的消息，参数和返回值的类型也应该是相同的。否则编译器就会提示警告<br><strong>重载：</strong> Objective-C是动态语言，参数的类型是在运行时确定的，所以不支持这种根据参数类型的不同来调用不同函数的重载。但是可以通过动态绑定让同一个消息选择器执行不同的功能来实现重载</p>\n<h2 id=\"类的前置声明\"><a href=\"#类的前置声明\" class=\"headerlink\" title=\"类的前置声明\"></a>类的前置声明</h2><p>当我定义一个类的时候，有时会将类实例变量、类方法的参数和返回值的类型指定为另外一个类。这种情况该如何定义： 可以在新定义的类的接口文件中引用原有类的头文件。<br>但是这种方式有一些缺点，头文件中除了类名之外，还有各种各样的其他信息的定义，而且还会引入新的引入。<br>如果仅仅是在类型定义的时候使用一下类名，则可以采用<strong>类的前置声明</strong> </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/NSObject.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">Volume</span>; // 声明要使用类<span class=\"title\">Volume</span></span></span><br></pre></td></tr></table></figure>\n<p>通过编译指令<code>@class</code> 告诉编译器Volume是一个类名。使用<code>@class</code>可以提升程序整体的编译速度。但是如果新定义的类中要使用原有类的具体成员或方法，就一定要引入原有类的头文件。</p>\n<h1 id=\"实例变量的数据封装\"><a href=\"#实例变量的数据封装\" class=\"headerlink\" title=\"实例变量的数据封装\"></a>实例变量的数据封装</h1><h2 id=\"实例变量的访问权限\"><a href=\"#实例变量的访问权限\" class=\"headerlink\" title=\"实例变量的访问权限\"></a>实例变量的访问权限</h2><p>Objective-C原则上不允许从对象外直接访问对象的实例变量。但是类A的方法中可以直接访问类A中包含self以外的其他实例的实例变量。同类型检查一样，能不能访问对象的实例变量也需要检查，这个检查在编译时完成。因此，只能访问使用静态类型定义的实例变量的内部变量。<br>下面是访问obj对象中实例变量myvar的语句写法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">obj-&gt;myvar</span><br></pre></td></tr></table></figure>\n<p>只有被访问的类的实例对象与方法所在类的类型一致时才能访问。如果是其他类，即使是父类对象，则无法访问。</p>\n<h2 id=\"访问器\"><a href=\"#访问器\" class=\"headerlink\" title=\"访问器\"></a>访问器</h2><p>Objective-C不允许从外部直接访问和修改实例对象的属性。而仅仅可以访问同一个类的其他实例对象的变量。我们通常会定义专门的方法来访问或修改实例变量。<br>例如，类中有一个float类型、变量名交weight的属性，从类外部访问这个属性的<strong>方法应和属性同名</strong>，如下所示：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">float</span>) weight</span><br></pre></td></tr></table></figure>\n<p>定义修改改属性的方法时，可以<strong>用set作为前缀，之后接要更改的属性的名称，属性名的第一歌字母要求大写</strong></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>) setWeight: (<span class=\"type\">float</span>)value</span><br></pre></td></tr></table></figure>\n<p>这种用于读取、修改实例对象属性的方法称为访问器或访问方法。</p>\n<h2 id=\"实例变量的可见性\"><a href=\"#实例变量的可见性\" class=\"headerlink\" title=\"实例变量的可见性\"></a>实例变量的可见性</h2><p>能否从外部访问实例变量决定了访问的**可见性(visibility)**。Objective-C中有四种可见性修饰符。但是需要注意的可见性修饰符并不影响通过访问器访问实例变量，只影响直接访问</p>\n<ul>\n<li><code>@private</code>: 只能在声明它的类内部访问，子类中不可以访问。</li>\n<li><code>@protected</code>: 能够被声明它的类和任何子类访问。没有显示置顶可见性的实例变量都是次属性</li>\n<li><code>@public</code>:作用范围最大，本类和其他类都可以直接访问</li>\n<li><code>@package</code>: 类所在的框架内，可以像public一样访问，框架外则同private<br>可以在实现部分定义实例变量。因为实例变量定义在实现文件中，因此即便外部模块拿到接口文件，也不知道类中定义了那些实例变量。所以这种形式定义的实例变量，可见性默认是private的，子类无法直接访问，只能通过访问方法或者属性声明的方法访问</li>\n</ul>\n<h1 id=\"类对象\"><a href=\"#类对象\" class=\"headerlink\" title=\"类对象\"></a>类对象</h1><h2 id=\"什么是类对象\"><a href=\"#什么是类对象\" class=\"headerlink\" title=\"什么是类对象\"></a>什么是类对象</h2><p>面向对象的语言中对类有两种认识，一种认为类只作为类型的定义，程序运行时不作为实体存在。另外一种认为类本身也作为一个对象存在。我们把后一种定义中类的对象称为<strong>类对象</strong>。<br>类对象有自己的方法和变量，分别称为类方法和类变量。与类实例的实例方法和实例变量进行区分。<br>Objective-C中类对象也称为factory，所以类方法也会被称为factory method.<br>类方法的一个典型例子就是创建类的实例对象: <code>[Class alloc]</code>。类对象接收alloc消息，并返回类的实例。<br>类对象在程序执行时自动生成，每个类只有一个类对象，不需要手动生成。每个类的所有实例对象都可以使用类方法。类方法可以访问类对象管理的变量。</p>\n<h2 id=\"类对象的类型\"><a href=\"#类对象的类型\" class=\"headerlink\" title=\"类对象的类型\"></a>类对象的类型</h2><p>id类型可以表示任何对象，类对象也可以用id类型来表示。Objective-C中还专门定义了一个<strong>Class</strong>类型用来表示类对象。所有的类对象都是Class类型。Class和id一样都是指针类型，只是一个地址，并不需要了解实际指向的内容。<strong>Nil</strong>被用来表示空指针（是Class，而不是对象），实际值为0.<br>NSObject中定义了类方法class，所有的类都可以使用这个方法来获取类对象。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class theClasss = flag ? [Volume <span class=\"keyword\">class</span>] : [MuteVolume <span class=\"keyword\">class</span>];</span><br><span class=\"line\"><span class=\"type\">id</span> v = [[theClass alloc] init];</span><br></pre></td></tr></table></figure>\n<p>将类名定义为消息接收者是类对象特有的功能，除此之外类名只能在类型定义时使用。<br>除了class类方法外，类NSObject还是有一个class实例方法。所有的实例对象都可以使用class实例方法，这个方法返回的是对象所属类的类对象。<br><strong>类方法的定义方式：</strong> 与实例方法的定义基本相同，唯一的区别在于开头的<code>-</code>号换成<code>+</code><br>继承的情况下，子类可以访问父类的类方法。<br>但是需要注意的是，<strong>类方法不能访问类中定义的实例变量和实例方法</strong>。类对象只有一个，类的实例对象可以有任意个。所以，如果类对象可以访问实例变量，就会不清楚访问的到底是哪个实例对象的变量。<br>其次，类方法在执行时使用self代表类对象自身，因此可以i通过给self发送消息的方式来调用类中的其他类方法。调用父类的类方法时，则使用关键字super</p>\n<h2 id=\"类变量\"><a href=\"#类变量\" class=\"headerlink\" title=\"类变量\"></a>类变量</h2><p>Objective-C不支持类变量（即静态成员变量）。Objective-C通过在实现文件中定义<strong>静态变量</strong>的方法来代替类变量。Objective-C在实现文件中定义了静态变量后，该变量的作用域就变为只在该文件中内有效。也就是说只有类的类方法和实例方法可以访问这个变量。在继承的情况下，因为static变量的作用域仅限于定义它的文件内，所以子类无法直接访问父类中定义的static变量，只能通过访问方法访问。</p>\n<h2 id=\"类对象的初始化\"><a href=\"#类对象的初始化\" class=\"headerlink\" title=\"类对象的初始化\"></a>类对象的初始化</h2><p>Objective-C的跟类NSObject中存在一个initialize类方法，可以通过使用这个方法来为各类对象进行初始化。在每个类接收到消息之前，为这个类调用一次initialize，调用之前要先调用父类的initialize方法。每个类的initialize方法只被调用一次。因为在初始化的过程中会自动调用父类的initialize方法，所以子类的initialize方法中不用显示调用父类的initialize方法。</p>\n","categories":["iOS"],"tags":["Objective-C"]},{"title":"HTTP概述","url":"/2023/12/01/Network/HTTP%E6%A6%82%E8%BF%B0/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","categories":["基础"],"tags":["计算机网络"]},{"title":"Objective-C - 类和继承","url":"/2023/11/30/Objective-C/Objective-C%20-%20%E7%B1%BB%E5%92%8C%E7%BB%A7%E6%89%BF/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"继承的概念\"><a href=\"#继承的概念\" class=\"headerlink\" title=\"继承的概念\"></a>继承的概念</h1><h2 id=\"父类和子类\"><a href=\"#父类和子类\" class=\"headerlink\" title=\"父类和子类\"></a>父类和子类</h2><p>我们在定义一个新类的类的时候，经常会遇到要定义的新类是某个类的扩展或者是对某个类的修正。这种情况，如果可以在已有类的基础上追加内容来定义新类，那么新类的定义将会变得更简单。<br>向这种通过扩展或者修改即有类来定义新类的方法叫继承(inheritance)。在继承关系中，被继承的类叫<strong>父类</strong>，通过继承关系新建的类称为子类。<br>继承意味着子类继承父类的所有特性，父类的数据成员和成员函数自动成为子类的数据成员和成员函数。除此之外，子类还可以：</p>\n<ul>\n<li>追加新的方法</li>\n<li>追加新的实例变量</li>\n<li>重新定义父类的方法<br>子类中重新定义父类的方法的行为叫做<strong>重写</strong>。为了避免命名上的混乱，C++中也将父类称为<strong>基类</strong> ，把子类称为<strong>派生类</strong>或<strong>导出类</strong></li>\n</ul>\n<h2 id=\"类的层次结构\"><a href=\"#类的层次结构\" class=\"headerlink\" title=\"类的层次结构\"></a>类的层次结构</h2><p>假如以某个类为父类生成若干子类，然后再继承这些子类并生成更多的子类，如此循环下去就可能会生成一棵倒立的树，它由通过继承而彼此关联的类组成，这样的树称为类层次结构。位于类层次最顶端的类称为<strong>根类</strong><br><strong>NSObject</strong>是Cocoa环境下的根类，Cocoa中所有的类都直接或间接地继承NSObject。新建的任何类都必须是NSObject或它的继承类的子类。NSObject中定义了所有Objective-C对象的基本方法。</p>\n<h1 id=\"利用继承定义新类\"><a href=\"#利用继承定义新类\" class=\"headerlink\" title=\"利用继承定义新类\"></a>利用继承定义新类</h1><h2 id=\"继承的定义\"><a href=\"#继承的定义\" class=\"headerlink\" title=\"继承的定义\"></a>继承的定义</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> 类名 : 父类名</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t实例变量的声明;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">方法声明;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>Objective-C中所有的类都要继承根类，而NSObject是Objective-C中所有类的根类。如果子类有想继承的类，就要直接指明该类为父类，否则就需要指定NSObject为父类。</p>\n<h2 id=\"类定义和头文件\"><a href=\"#类定义和头文件\" class=\"headerlink\" title=\"类定义和头文件\"></a>类定义和头文件</h2><p>接口部分通常被声明为一个头文件，而这对继承来说也很重要。假设有一个已经定义好的类Alpha，那么头文件<code>Alpha.h</code>就应该已经存在。要定义类Alpha的子类Beta的时候，头文件<code>Beta.h</code>中必须包含<code>Alpha.h</code>。不知道父类定义的话是无法定义子类的。所以<strong>包含父类接口的头文件是必须的</strong>。<br>类的实现部分必须引入包含类的接口部分的头文件。实现部分需要包含新增和重写的方法的实现。当然实现部分也可以定义各种局部函数和变量。<br>类的定义可以不断地往下扩展，但无论怎么扩展，只要保证了这种头文件的引入方式，任何一个派生类中就能使用父类中定义的变量和方法。</p>\n<h2 id=\"调用父类的方法\"><a href=\"#调用父类的方法\" class=\"headerlink\" title=\"调用父类的方法\"></a>调用父类的方法</h2><p>子类继承父类之后，如果希望调用父类的方法，可以通过<strong>super</strong>关键字来发送消息。使用super发送消息后，就会调用父类或父类的父类中定义的方法。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"variable language_\">super</span> method];</span><br></pre></td></tr></table></figure>\n<p>super和self不同，并不确定指向某个对象。所以super只能被用于调用父类的方法，不能通过super完成赋值，也不能把方法的返回值指定为super。</p>\n<h2 id=\"初始化方法的定义\"><a href=\"#初始化方法的定义\" class=\"headerlink\" title=\"初始化方法的定义\"></a>初始化方法的定义</h2><p>新追加的实例变量有时需要被初始化。另外，子类也可能需要同父类不同的初始化方法。这些情况下就需要为子类定义自己的初始化方法。<br>子类中重写init初始化方法的时候，通常按照一下逻辑：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">id</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">self</span> = [<span class=\"variable language_\">super</span> init] <span class=\"comment\">/* 一定要在第一行调用父类的init方法 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> != <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">\t\t子类专有的初始化操作</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果所有类的初始化方法都遵循先调用父类init方法的写法，那么根类NSObject的init方法就一定会被执行。否则生成的对象就无法使用。与此同时，这样做也可以防止漏掉父类中定义的实力变量的初始化。<br>执行的时候父类的初始化方法可能会出错。出错时则返回nil，这种情况下子类也不需要再进行初始化，直接返回nil就可以了。<br>生成实力对象的方法alloc会把实力对象的变量都初始化为0(后续会提到实力变量isa除外)。所以，如果子类中新追加的实例变量的初值可以为0，则可以跳过子类的初始化。但是为了明确是否可以省略，最好为初值可为0的变量加上注释。<br>从程序的书写角度来说，设定初始值的方法有两种，既可以在初始化方法中一次性完成实例变量的初始化，也可以在初始化方法中先设置实例变量为默认值，然后再调用别的方法来设置实例变量。</p>\n<h1 id=\"使用继承的程序示例\"><a href=\"#使用继承的程序示例\" class=\"headerlink\" title=\"使用继承的程序示例\"></a>使用继承的程序示例</h1><h2 id=\"追加新方法的例子\"><a href=\"#追加新方法的例子\" class=\"headerlink\" title=\"追加新方法的例子\"></a>追加新方法的例子</h2><p>我们定义一个带有静音功能的类MuteVolume。该类只有一个功能，即当收到mute消息时，设置音量为最小</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MuteVolume.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;Volume.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MuteVolume</span></span></span><br><span class=\"line\">- (<span class=\"type\">id</span>)mute;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MuteVolume.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;MuteVolume.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MuteVolume</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">id</span>) mute</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tval = min;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法重写的例子\"><a href=\"#方法重写的例子\" class=\"headerlink\" title=\"方法重写的例子\"></a>方法重写的例子</h2><p>假设该例子要实现两个功能。第一个功能是，当再次收到mute消息时，音量会恢复原职；第二个功能是，在静音状态下收到up或者down消息时，会返回最小音量，同时改变音量值</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MuteVolume.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MuteVolume</span> : <span class=\"title\">Volume</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">BOOL</span> muting;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* override */</span></span><br><span class=\"line\">- (<span class=\"type\">id</span>)initWIthMin: (<span class=\"type\">int</span>)a Max: (<span class=\"type\">int</span>)b step: (<span class=\"type\">int</span>)s;</span><br><span class=\"line\">- (<span class=\"type\">int</span>)value;</span><br><span class=\"line\">- (<span class=\"type\">id</span>) mute;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MuteVolume.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;MuteVolume.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MuteVolume</span></span></span><br><span class=\"line\"><span class=\"comment\">/* override */</span></span><br><span class=\"line\">- (<span class=\"type\">id</span>)initWithMin: (<span class=\"type\">int</span>)a max: (<span class=\"type\">int</span>)b step: (<span class=\"type\">int</span>)s</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">self</span> = [<span class=\"variable language_\">super</span> initWithMin:a max:b step:s];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> != <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t\tmuting = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* override */</span></span><br><span class=\"line\">- (<span class=\"type\">int</span>)value</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> muting ? min : val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">id</span>)mute</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tmuting = !muting;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"继承和方法调用\"><a href=\"#继承和方法调用\" class=\"headerlink\" title=\"继承和方法调用\"></a>继承和方法调用</h1><p><strong>使用self调用方法：</strong><br>如果想在一个方法中调用当前类中定义的方法，可以利用self。但如果存在继承关系，通过self调用方法时需要格外注意：<strong>self始终指向收到当前消息的示例变量</strong></p>\n<p><strong>使用super调用方法：</strong><br>super调用的是父类的方法，而至于到底调用了哪个方法则是由编译时类的继承关系决定的。</p>\n<p>我们用一个简单的程序来验证一下上面所描述的内容</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/NSObject.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">A</span>: <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)method1;</span><br><span class=\"line\">- (<span class=\"type\">void</span>)method2;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">A</span></span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)method1 &#123; printf(<span class=\"string\">&quot;method1 of Class A\\n&quot;</span>); &#125;</span><br><span class=\"line\">- (<span class=\"type\">void</span>)method2 &#123; printf(<span class=\"string\">&quot;method2 of Class A\\n&quot;</span>); &#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">B</span> : <span class=\"title\">A</span></span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)method;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">B</span></span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)method2;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">B</span></span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)method2 &#123;</span><br><span class=\"line\">\tprintf(<span class=\"string\">&quot;method2 of Class B\\n&quot;</span>);</span><br><span class=\"line\">\tprintf(<span class=\"string\">&quot;self ---&gt; &quot;</span>);</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span> method1];</span><br><span class=\"line\">\tprintf(<span class=\"string\">&quot;super ---&gt; &quot;</span>);</span><br><span class=\"line\">\t[<span class=\"variable language_\">super</span> method2];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">C</span> : <span class=\"title\">B</span></span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)method1;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">C</span></span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)method1 &#123; printf(<span class=\"string\">&quot;method1 of Class C\\n&quot;</span>); &#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> main(<span class=\"type\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">id</span> x = [[B alloc] init];</span><br><span class=\"line\">\t<span class=\"type\">id</span> y = [[C alloc] init];</span><br><span class=\"line\">\tprintf(<span class=\"string\">&quot;--- instance of B ---- \\n&quot;</span>);</span><br><span class=\"line\">\t[x method1];</span><br><span class=\"line\">\t[x method2];</span><br><span class=\"line\">\tprintf(<span class=\"string\">&quot;--- instance of C --- \\n&quot;</span>);</span><br><span class=\"line\">\t[y method1];</span><br><span class=\"line\">\t[y method2];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--- instance of B ---</span><br><span class=\"line\">method1 of Class A</span><br><span class=\"line\">method2 of Class B</span><br><span class=\"line\">self --&gt; method1 of Class A</span><br><span class=\"line\">super --&gt; method2 of Class A</span><br><span class=\"line\">--- instance of A ---</span><br><span class=\"line\">method1 of Class C</span><br><span class=\"line\">method2 of Class B</span><br><span class=\"line\">self --&gt; method1 of Class C</span><br><span class=\"line\">super --&gt; method2 of Class A</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"方法定义时的注意事项\"><a href=\"#方法定义时的注意事项\" class=\"headerlink\" title=\"方法定义时的注意事项\"></a>方法定义时的注意事项</h1><h2 id=\"局部方法\"><a href=\"#局部方法\" class=\"headerlink\" title=\"局部方法\"></a>局部方法</h2><p>实现接口声明中的方法时，可以把具备独立功能的部分独立出来定义成子方法。一般情况下，这些方法都只供内部调用，不需要包含在类的接口中对外公开。这些方法，被称为局部方法。局部方法只能在被定义在局部方法之后的方法调用。定义顺序方法出现的问题，可以在后续的[[范畴]]中解决</p>\n","categories":["iOS"],"tags":["Objective-C"]},{"title":"Objective-C - 程序设计","url":"/2023/11/29/Objective-C/Objective-C%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"对象和消息\"><a href=\"#对象和消息\" class=\"headerlink\" title=\"对象和消息\"></a>对象和消息</h1><h2 id=\"消息表达式\"><a href=\"#消息表达式\" class=\"headerlink\" title=\"消息表达式\"></a>消息表达式</h2><p>在Objective-C中，id类型是一个独特的数据类型。id类型的变量可以存放任何数据类型的对象。定义一个id类型变量obj的方法如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">id</span> obj;</span><br></pre></td></tr></table></figure>\n<p>而向obj发送msg消息的语法如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">[obj msg];</span><br></pre></td></tr></table></figure>\n<p>这就是<strong>消息表达式</strong>的语法。其中，消息接收者是一个对象。<br>Objective-C允许嵌套消息表达式，每个消息表达式的返回值都可以作为消息的接收者，继续接收消息</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">[[[obj msg1] msg2] msg3];</span><br></pre></td></tr></table></figure>\n<p>消息由<strong>消息关键字</strong>组成，消息关键字的命名规则同变量名的命名规则一样。<br>消息关键字的末尾有”:”时，表示这个消息带有参数。“:“后面紧跟的就是实际的参数</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">[printInfo setLeftMargin: <span class=\"number\">60.0</span>];</span><br></pre></td></tr></table></figure>\n<p>发送带有多个参数的消息的时候，可以通过多个“关键字: 变量“的写法完成调用。也可以省略关键字而至通过”:”将变量连接起来</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">[manager fileExistsAtPath: dirname isDirectory: &amp;isDir];</span><br><span class=\"line\">[view lineTo: <span class=\"number\">1.412</span>: (y + <span class=\"number\">1.0</span>)];</span><br></pre></td></tr></table></figure>\n\n<p>函数通过函数名来区分，而在Objective-C中，消息是通过消息名进行区分的。带参数和不带参数的消息名，例如”copy”和”copy:”是不同的消息名。</p>\n<h2 id=\"实例变量的生成和初始化\"><a href=\"#实例变量的生成和初始化\" class=\"headerlink\" title=\"实例变量的生成和初始化\"></a>实例变量的生成和初始化</h2><p>在OC中使用一个对象前，首先需要调用类的构造函数以生成对象。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">[类名 alloc];</span><br></pre></td></tr></table></figure>\n<p>alloc执行后即可完成对象所需空间的分配。但还没有对对象进行初始化。不同的类会提供不同的初始化方法，同一个类也可能提供多个初始化方法。<br>Cocoa中的初始化方法通常都是init或以init开头。下面的语句完整地创建并初始化了Cocoa中的某个类</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">[[类名 alloc] init]</span><br></pre></td></tr></table></figure>\n<p>另外，对象生成后只能调用一次初始化方法，来为对象中的各个变量设置初值。但是初始化方法不具备将对象中的信息重置的功能。如果需要将对象中的属性重置，则需要额外实现一个函数。<br>另外，有的类的方法会返回一个初始化好的对象，所以可以不通过alloca而使用别的方法来生成对象。</p>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"类的接口声明\"><a href=\"#类的接口声明\" class=\"headerlink\" title=\"类的接口声明\"></a>类的接口声明</h2><p>在OC中，接口（interface）和实现（implementation）是分离开的。<br>类的接口部分定义了类的实例变量和方法。类的接口声明通常声明为头文件，提供给要调用这个类的模块引用。接口的定义如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> 类名 : 父类</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t实例变量的定义;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">方法声明;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>在Objective-C中，类接口的声明以编译指令<code>@interface</code>开头，以<code>@end</code>结尾。所有Objective-C编译指令都以<code>@</code>字符开头。<br>实例变量的声明和C语言中定义变量的方法一样，使用<code>变量类型 变量名</code>的形式。<br>而方法的声明如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">-  (<span class=\"type\">id</span>)callAtRow: (<span class=\"type\">int</span>)row column:(<span class=\"type\">int</span>)col;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类的实现\"><a href=\"#类的实现\" class=\"headerlink\" title=\"类的实现\"></a>类的实现</h2><p>类的实现部分以编译指令<code>@implementation</code>开始，以<code>@end</code>结束。具体语法如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span></span></span><br><span class=\"line\">方法的实现</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>类的实现部分不用再次声明父类。实现部分包含了接口部分声明的所有方法的实现。<br>方法实现部分的第一行代码和方法声明部分完全相同，以后接上<code>&#123;&#125;</code>，并将具体实现的代码写在<code>&#123;&#125;</code>里面。<br>方法内部可以自由使用类的实例变量。</p>\n","categories":["iOS"],"tags":["Objective-C"]},{"title":"React Native 原架构","url":"/2023/10/06/React%20Native/React%20Native%20%E5%8E%9F%E6%9E%B6%E6%9E%84/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h1 id=\"移动端的发展\"><a href=\"#移动端的发展\" class=\"headerlink\" title=\"移动端的发展\"></a>移动端的发展</h1><p>上世纪 90 年代，3Com 公司的 Palm OS 成为移动领域（掌上电脑）的霸主，市场占有率达 90%。直到 20 世纪末，微软推出了 Windows CE 和 Windows Mobile，取代了 Palm OS。随后，Symbian 和 Blackberry 昙花一现，也曾一度占有 40%的市场。再后来，W3C 立项 HTML5，并于 2008 年 1 月发布 HTML5 第一份正式草案。2007 年 1 月，苹果推出了第一部 iPhone，iOS 系统诞生。同年 11 月，google 宣布推出 Android 系统，并于次年 10 月发布了第一部 Android 智能手机。至此，移动端的基本格局已经奠定。</p>\n<p>2010-2012 年：FaceBook 牵头成立 Moblie Web 工作组，大举进攻移动领域，Web App 的呼声越来越高，一度认为 Native App 在 3 年内会消亡</p>\n<p>2012 年：FaceBook 宣布放弃使用 HTML 5 构造自己的主题应用，HTML 5 进入最惨淡的一年</p>\n<p>2014 年 10 底：HTML5 定稿，迎来了原生+HTML5 的混合开发模式</p>\n<p>2015 年：FackBook 推出 React Native</p>\n<p>2018 年 2 月：Google 发布 Flutter 第一版本</p>\n<p>2018 年 6 月：FaceBook 宣布对 React Native 进行大规模重构，并在 2023 年基本完成重构工作</p>\n<h1 id=\"跨平台方法的对比\"><a href=\"#跨平台方法的对比\" class=\"headerlink\" title=\"跨平台方法的对比\"></a>跨平台方法的对比</h1><blockquote>\n<p>[!question] 为什么要进行跨平台的研究<br>【微观上】：企业要提高开发效率，降低开发成本，实现一次编码，到处运行；【宏观上】：现在处于多端发展时代，多种终端生态互不兼容，造成生产力浪费，势必会有一种新技术代表先进生产力</p>\n</blockquote>\n<h2 id=\"Native-App\"><a href=\"#Native-App\" class=\"headerlink\" title=\"Native App\"></a>Native App</h2><p>第三方应用程序会与平台进行交互，以创建 widgets（组件） 或访问相机等服务。其中 widgets 呈现给屏幕画布，并将事件传回给 widgets</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/ReactNative/NativeApp%E6%9E%B6%E6%9E%84.png\"></p>\n<h2 id=\"基于-WebView-的第一代跨平台框架\"><a href=\"#基于-WebView-的第一代跨平台框架\" class=\"headerlink\" title=\"基于 WebView 的第一代跨平台框架\"></a>基于 WebView 的第一代跨平台框架</h2><p>第一代跨平台框架基于 JavaScript 和 WebViews，代表者有：PhoneGap，微信小程序。</p>\n<p>第三方应用程序创建 HTML 并将其显示在平台的 WebView 上，对于平台提供的一些系统服务，通过 JS Bridge 来调用。由于这些调用不是很频繁，JS Bridge 并不会成为性能瓶颈。然而，一个完整 HTML5 页面的展示要经历浏览器控件的加载、解析和渲染三大过程，性能消耗要比原生开发增加 N 个数量级，所以这种方案的瓶颈在于 WebView 对于 H5 页面的渲染。这种开发模式开发的 App 既有原生应用代码又有 Web 应用代码，因此又被称为 Hybrid App（混合应用程序）</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/ReactNative/WebView%E6%9E%B6%E6%9E%84.png\"></p>\n<h2 id=\"以-React-Native-为代表的第二代跨平台框架\"><a href=\"#以-React-Native-为代表的第二代跨平台框架\" class=\"headerlink\" title=\"以 React Native 为代表的第二代跨平台框架\"></a>以 React Native 为代表的第二代跨平台框架</h2><p>这种方案也称为<strong>泛 Web 容器方案</strong> ，这种方案放弃了 WebView 渲染，采用原生自带的 UI 组件代替了核心的渲染引擎，所以这种方案的性能要比第一代方案好很多。代表者就是 RN 、Weex。同时这种方案保持了 JavaScript 作为开发语言，支持前端丰富的生态（比如 RN 使用 React.js 极大地方便了 UI 的创建）。由于前端和 Native 的交互都要通过中间的 Bridge，很自然的 Bridge 就成了这种方案的性能瓶颈<br><img src=\"/img/friend_404.gif\" data-original=\"/img/ReactNative/ReactNative%E6%97%A7%E6%9E%B6%E6%9E%84.png\"></p>\n<h2 id=\"以-Flutter-为代表的第三代跨平台框架\"><a href=\"#以-Flutter-为代表的第三代跨平台框架\" class=\"headerlink\" title=\"以 Flutter 为代表的第三代跨平台框架\"></a>以 Flutter 为代表的第三代跨平台框架</h2><p>为什么说 Flutter 是一种新的方案呢？因为他采用了一种自绘引擎的方式，和以往的方案都不一样；Flutter 既不用 WebView 进行组件渲染，也不适用原生组件进行渲染，他完全自己搞了一套跨平台 UI 渲染框架，渲染引擎依靠跨平台的 Skia 图形库来实现，手机平台只需要提供一块画布即可。同时开发语言使用即支持 JIT 又支持 AOT 的 Dart 语言，即提升了执行效率，也为支持动态化提供可能<br><img src=\"/img/friend_404.gif\" data-original=\"/img/ReactNative/Flutter%E6%9E%B6%E6%9E%84.png\"></p>\n<h1 id=\"ReactNative-架构一览\"><a href=\"#ReactNative-架构一览\" class=\"headerlink\" title=\"ReactNative 架构一览\"></a>ReactNative 架构一览</h1><p>本文基于 React Native 0.54.3 版本 Android 的架构分析</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/ReactNative/ReactNative%E6%9E%B6%E6%9E%84%E5%B1%82%E7%BA%A7.png\"><br>RN 的老架构主要包含 React、JavaScript、Bridge 和 Native 四个部分。从上到下可以分成四层，分别是 JS 代码层、JS 引擎层、通信层、原生层。最上面的 JS 代码层提供 React.js 支持，React.js 的 JSX 代码转换为 JS 代码运行在 [[JavaScriptCore]] 提供的 JavaScript 运行时环境中，通信层将 JavaScript 与 Native 层连接起来；通信层又分为三部分，其中 Shadow Tree 用来定义 UI 效果及交互功能、Native Modules 提供 Native 功能（比如相册、蓝牙等）、而他们之间的相互通信使用的是 JSON 异步消息</p>\n<p>基于上述架构，RN 运行时创建三个线程：</p>\n<ul>\n<li>「<strong>JS Thread</strong>」： 主要负责 React，JS 的执行，输出 App 的视图信息（结构、样式、属性等）</li>\n<li>「<strong>Shadow Thread</strong>」：根据 JS 线程的视图信息，创建出用于布局计算的 ShadowTree；（主要用到 UIManagerModule，是 RN 中非常重要的 Native Module，故也叫做 Native Module Thread）</li>\n<li>「<strong>Main Thead</strong>」：根据 ShadowTree 提供的完整试图信息，负责真实 Native View 的创建<br>下面，将分为启动流程、渲染原理、通信机制三个部分详细剖析一下 RN 的实现原理</li>\n</ul>\n<h1 id=\"启动流程\"><a href=\"#启动流程\" class=\"headerlink\" title=\"启动流程\"></a>启动流程</h1><p>总结起来，启动流程主要做了两件事：一件是准备环境，一件事调用 JS 侧的入口函数<br>准备环境：在后台创建上下文、初始化通信桥、加载 JSBundle、初始化 JS 执行环境。<br>调用 JS 侧的入口函数：即调用 Appregistry.js 的 runApplication 方法，为一次 Native 到 JS 的调用</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/ReactNative/RN%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png\"></p>\n<h1 id=\"渲染原理\"><a href=\"#渲染原理\" class=\"headerlink\" title=\"渲染原理\"></a>渲染原理</h1><p><img src=\"/img/friend_404.gif\" data-original=\"/img/ReactNative/RN%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.png\"></p>\n<p>RN 运行时会创建三个线程：JS Thread、Shadow Thread、Main Thread，在这三个线程中分别会创建三棵树，JS 线程中会创建一棵叫做<strong>Fiber Tree</strong>，在 Shadow 线程中会创建一棵树叫做<strong>Shadow Tree</strong>，在 UI 线程中则是 <strong>View Tree</strong> 。其中，Fiber Tree 在 JS 侧创建，Shadow Tree 和 View Tree 在 Native 测创建，RN 渲染机制的重点就是这三棵树的创建和同步，关键步骤如下：</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/ReactNative/RN%E6%B8%B2%E6%9F%93Tree%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%8C%E6%AD%A5.png\"></p>\n<ol>\n<li><strong>第一步：</strong> 通过 React.js 的 JSX 定义 UI 结构</li>\n<li><strong>第二步：</strong> 编译阶段，通过 Babel 将 JSX 转化为 React.createElement 的形态</li>\n<li><strong>第三步：</strong> 在 JS 侧，通过深度优先遍历将 JSX 编写的 UI 组件转换为 Fiber Tree 结构，每个组件节点都包含子组件、父组件和兄弟组件的引用</li>\n<li><strong>第四步：</strong> JS 侧在创建 Fiber Tree 各个节点的时候会通过 Bridge 桥向 Native 侧发送对应的指令。Native 侧收到这些指令之后会创建对应的 Shadow Tree 节点，同时会生成对应的 UIViewOperation，加入到 UIViewOperationQueue 中，以供 UI 线程进行真正的 UI 操作。JS 侧发送完一批 UI 指令之后会触发 Native 侧的 onBatchComplete 回调，进而后续遍历 ShadowTree，分别计算每个节点的宽度和高度，然后前序遍历 ShadowTree，确定每个节点的最终位置，生成相应的 UpdateLayoutOperation，加入到 UIViewOperationQueue 中</li>\n<li><strong>第五步：</strong> 出发 FrameCallback，从 UIViewOperationQueue 中依次取出 UIViewOperation，生成对应的 View Tree，挂载到 RootView，进行原生 UI 渲染逻辑</li>\n</ol>\n<blockquote>\n<p>[!question]- 虚节点和 Layout Only 节点区别？</p>\n<ol>\n<li>虚节点在计算布局时会被忽略，也不会生成相应的 Native 节点</li>\n<li>LayoutOnly 节点指一个节点只会影响到它的子节点的位置，而本身不需要绘制任何内容，那么这个节点就是 LayoutOnly 节点，也不会生成相应的 Native 控件</li>\n</ol>\n</blockquote>\n<h1 id=\"通信机制\"><a href=\"#通信机制\" class=\"headerlink\" title=\"通信机制\"></a>通信机制</h1><p><img src=\"/img/friend_404.gif\" data-original=\"/img/ReactNative/RN%E5%8E%9F%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.png\"><br>在 RN 中有三个线程：JS 线程、UI 线程、Shadow 线程（即 Native Modules 线程），而在 Native Modules 线程中，主要用于进行 Yoga 布局计算，同时也负责 C++层和原生通信。我们知道 Java 可以通过 JNI 的方式和 C++代码实现相互调用，而 Objective-C 可以直接调用 C++代码。JS 可以通过 [[JavaScriptCore]] 实现和 C++的相互调用，而 JavaScriptCore 是由 C++实现的 JS 引擎，所以很自然的，C++就成为了连接原生和 JS 的桥梁。</p>\n<p>所以 RN 的通信机制总结起来就是一句话：<strong>一个 C++实现的 bridge (桥)打通了原生和 JS，实现了两者的相互调用</strong></p>\n<h2 id=\"桥的初始化\"><a href=\"#桥的初始化\" class=\"headerlink\" title=\"桥的初始化\"></a>桥的初始化</h2><p>在 RN 的启动流程中，会对通信桥进行初始化。通信桥的初始化最关键的就是创建两张表和建立两个桥。两张表中，一张是 JavaScriptModuleRegistry，供原生调用 JS 使用，一张是 NativeModuleRegistry，供 JS 调用原生使用；两个桥中，一个是 NativeToJSBridge，是原生调用 JS 的桥梁，一个是 JSToNativeBridge，JS 调用原生的桥梁。</p>\n<h2 id=\"Native-调用-JS\"><a href=\"#Native-调用-JS\" class=\"headerlink\" title=\"Native 调用 JS\"></a>Native 调用 JS</h2><p>Native 调用 JS 的流程相对简单：</p>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/ReactNative/RNNative%E8%B0%83%E7%94%A8JS.png\"></p>\n<ol>\n<li>在 Java 层把要实现的功能编写成接口并继承 JavaScriptModule，并交由 ReactPackage 管理，最终会在RN初始化的时候添加到JavaScriptModuleRegistry注册表中</li>\n<li>JavaScriptModuleRegistry通过动态代理生成对应的JavaScriptModule，然后通过invoke()调用相应的JS方法，该方法会进一步去调用CatalystInstanceImpl.callJSFunction，该方法会通过JNI将相关参数传递到C++层</li>\n<li>C++层通过NativeToJsBridge将callFunction的消息放入消息队列等待执行；C++层中保有MessageQueue中的一些属性对象，通过这些属性对象进入JS层</li>\n<li>在JS层里，找到对应的JavaScriptModule及方法执行</li>\n</ol>\n<h2 id=\"JS调用Native\"><a href=\"#JS调用Native\" class=\"headerlink\" title=\"JS调用Native\"></a>JS调用Native</h2><p>在JSToNative的通信方式中，又分为两种调用方式：</p>\n<ul>\n<li>「异步调用」：指的是在JSToNative的通信方式中，调用的发起在JS线程，逻辑处理和计算在Native Module线程和UI线程，异步的方式不会阻塞JS线程</li>\n<li>「同步调用」：指的是调用和处理过程都发生在JS线程中；如果逻辑计算简单，这没什么影响，但是如果逻辑计算复杂，那肯定得卡死JS线程。</li>\n</ul>\n<p><img src=\"/img/friend_404.gif\" data-original=\"/img/ReactNative/JSCallbackRN.png\"><br>整个流程可以分为两个部分，第一个部分是JS调用Native，第二个部分是Native将执行结果回调至JS侧（和Native调用JS的流程很相似）<br>JS调用Native流程如下：</p>\n<ol>\n<li>从JS侧进入C++层，通过JSC桥接获取Java Module的注册表，然后回到JS侧，将它转换为对应的JS Native  Module，并根据不同的调用类型，将xxMethod的调用封装成消息，放入MessageQueue的队列里</li>\n<li>xxMethod消息处理的时候，会进入C++层，拿到对应的module信息，通过JSToNativeBridge，将该函数调用消息放到线程的消息队列中等待执行。此时C++层的函数调用会映射为同名的Java层JavaModuleWrapper对象，并调用其中的invoke方法，传入的参数是methodId和对应的参数信息</li>\n<li>Java层的JavaModuleWrapper对象，根据参数信息，找到对应的JavaMethodWrapper对象，再执行其invoke方法，通过反射调用对应的NativeModule，从而完成JS到Native的调用</li>\n</ol>\n<h1 id=\"性能瓶颈与新架构\"><a href=\"#性能瓶颈与新架构\" class=\"headerlink\" title=\"性能瓶颈与新架构\"></a>性能瓶颈与新架构</h1><p>基于此架构，中间层Bridge必然成为RN的性能瓶颈，其存在以下问题：</p>\n<ol>\n<li>通信效率低下，容易出现堵塞<blockquote>\n<p>JS层和Native层只能通过桥来通信，多次线程切换、串行消息处理、参数通过JSON序列化和反序列化传递，导致效率低下，容易出现堵塞</p>\n</blockquote>\n</li>\n<li>异步调用导致不能同步响应，用户体验差<blockquote>\n<p>受限制于通信机制，RN里JS和Native侧相互之间只能异步调用，用户的操作和APP的响应是异步的，且之间可能会有不小的延迟，用户体验不佳</p>\n</blockquote>\n</li>\n</ol>\n<p>而新架构将解决这些问题，新架构的主要内容有：</p>\n<ul>\n<li>JSI： 增加引擎抽象层，实现引擎解耦，同时支持JS持有C++ HostObject类型对象引用，实现JS和Native的相会感知</li>\n<li>TurboModule：重构后的NativeModules，用于向前端暴露Native能力，实现NativeModule的按需加载和JS与Native的同步调用</li>\n</ul>\n","categories":["前端"],"tags":["ReactNative"]}]